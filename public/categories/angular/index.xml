<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Angular on David Cai | Blog</title>
    <link>http://davidcai.github.io/blog/categories/angular/</link>
    <description>Recent content in Angular on David Cai | Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 14 Sep 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://davidcai.github.io/blog/categories/angular/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Tips on Promise and $http Service</title>
      <link>http://davidcai.github.io/blog/posts/angular-promise/</link>
      <pubDate>Mon, 14 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://davidcai.github.io/blog/posts/angular-promise/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve been reviewing a lot of Angular code lately. One common problem I found is the unnecessary use of deferred object to resolve and reject promises. In this post, I will illustrate a simplified approach. Another problem is a mix of then, catch, two callbacks in then, success, and error. I will go through each, and propose adopting a single style that can also be applied when using other Promise libraries.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;resolve-promise&#34;&gt;Resolve Promise&lt;/h2&gt;

&lt;p&gt;The following snippet uses $http service to make a REST call, and resolve the returned data from the response. This is a common pattern I often find in Angular code, however, the code is not optimal (see below).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/////////////////////////////////////////////////
// Not preferred. Unnecessary usage of deferred
/////////////////////////////////////////////////
function getUser($q, $http) {
  var deferred = $q.defer();

  $http.get(&#39;...&#39;).then(function(response) {
    deferred.resolve(response.data);
  });

  return $q.promise;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code can be simplified to this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//////////////
// Preferred
//////////////
function getUser($http) {
  return $http.get(&#39;...&#39;).then(function(response) {
    return response.data;
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, the &lt;code&gt;then&lt;/code&gt; function accepts three callbacks: successCallback, errorCallback, and notifyCallback. If you return a value in the successCallback or errorCallback, the returned value will be used to &lt;em&gt;resolve&lt;/em&gt; the promise. You don&amp;rsquo;t have to explicitly call &lt;code&gt;deferred.resolve(response.data)&lt;/code&gt; to resolve the promise. Instead, simply &lt;code&gt;return response.data&lt;/code&gt; in &lt;code&gt;then&lt;/code&gt;&amp;rsquo;s callback.&lt;/p&gt;

&lt;p&gt;Second, the &lt;code&gt;then&lt;/code&gt; function returns a new promise, so no need to use &lt;code&gt;$q&lt;/code&gt; to create a deferred object and return its associated promise. Just return the promise created by &lt;code&gt;then&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;reject-promise&#34;&gt;Reject Promise&lt;/h2&gt;

&lt;p&gt;What about error handling? Using the not preferred example, we can call &lt;code&gt;deferred.reject&lt;/code&gt; in the error callback to reject the promise:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/////////////////////////////////////////////////
// Not preferred. Unnecessary usage of deferred
/////////////////////////////////////////////////
function getUser($q, $http) {
  var deferred = $q.defer();

  $http.get(&#39;...&#39;).then(
    function(response) { // Success callback
      deferred.resolve(response.data); // Resolve
    },
    function(response) { // Error callback
      deferred.reject(response); // Reject
    }
  );

  return $q.promise;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, a simplified solution is again to use &lt;em&gt;return&lt;/em&gt; instead of &lt;em&gt;reject&lt;/em&gt;. But, what shall we return? You probably think to return the response in the error callback like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function getUser($http) {
  return $http.get(&#39;...&#39;).then(
    function(response) {
      return response.data;
    },
    function(response) { // Error callback
      return response; // &amp;lt;&amp;lt;&amp;lt; Wrong
      // Or return false; // &amp;lt;&amp;lt;&amp;lt; Still wrong
    }
  );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As I mentioned above, values returned from the successCallback or the errorCallback are considered to be resolved values for the promise. So the &lt;code&gt;return response&lt;/code&gt; in the error callback will resolve instead reject the promise. Even when the returned value is falsy, the falsy value will be considered as a resolved value. The correct way is to return a rejected promise using &lt;code&gt;$q.reject(response)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//////////////
// Preferred
//////////////
function getUser($q, $http) {
  return $http.get(&#39;...&#39;).then(
    function(response) {
      return response.data;
    },
    function(response) { // Error callback
      return $q.reject(response); // Use $q.reject
    }
  );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Besides the errorCallback in &lt;code&gt;then&lt;/code&gt; function, Promise has another method &amp;ndash; &lt;code&gt;catch&lt;/code&gt; to take an error callback. I personally prefer the &lt;code&gt;then&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; pair over the two callbacks in &lt;code&gt;then&lt;/code&gt; for its readability.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;///////////////////////
// Catch is preferred
///////////////////////
function getUser($q, $http) {
  return $http.get(&#39;...&#39;).then(
    function(response) {
      return response.data;
    }
  ).catch( // Catch
    function(response) {
      return $q.reject(response);
    }
  );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above code, &lt;code&gt;then&lt;/code&gt; is used only for success callback. A &lt;code&gt;catch&lt;/code&gt; is basically a &lt;code&gt;then()&lt;/code&gt; without success callback &amp;ndash; &lt;code&gt;then(angular.noop, errorCallback)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The difference from &lt;code&gt;then(successCallback, errorCallback)&lt;/code&gt; is that &lt;code&gt;catch&lt;/code&gt; is chained of the promise returned by &lt;code&gt;then&lt;/code&gt;. However, the errorCallback in &lt;code&gt;then&lt;/code&gt; is chained of the original promise returned by &lt;code&gt;$http.get()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Please be advised that in IE8 &lt;code&gt;catch&lt;/code&gt; has special meaning, so instead of the dot syntax, write &lt;code&gt;[&#39;catch&#39;]&lt;/code&gt;. Yes, in IE8, &lt;code&gt;catch&lt;/code&gt; is the catch :)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/////////////////
// Catch in IE8
/////////////////
function getUser($q, $http) {
  return $http.get(&#39;...&#39;).then(
    function(response) {
      return response.data;
    }
  )[&#39;catch&#39;]( // Catch
    function(response) {
      return $q.reject(response);
    }
  );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;rsquo;t need to handle the error in the &lt;code&gt;getUser&lt;/code&gt; function shown above, you can drop the entire error callback, and let &lt;code&gt;getUser&lt;/code&gt;&amp;rsquo;s consuming code to handle the error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//////////////
// Preferred
//////////////
function getUser($q, $http) {
  return $http.get(&#39;...&#39;).then(function(response) {
    return response.data;
  });
}

// getUser&#39;s consuming code
getUser().then(
  function(data) { // Success callback
    // Do something about data
  },
  function(response) { // Error callback
    // Handle error state
  }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;success-and-error-in-http-service&#34;&gt;Success and Error in $http Service&lt;/h2&gt;

&lt;p&gt;In old versions (1.3 and less) of Angular, $http service has two additional methods &amp;ndash; success() and error(), which are similar to then(), however, the subtle differences are important:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$http.get(&#39;&#39;)
  .success(function(data) {
    ...
  })
  .error(function(error) {
    ...
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These two methods are deprecated in Angular 1.4 partially for the confusion they introduced. The first argument passed into &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; callbacks is not the response object itself, instead, it is the data unwrapped from the response object. However, in &lt;code&gt;then&lt;/code&gt; callback, you call &lt;code&gt;response.data&lt;/code&gt; to retrieve the data. Here is a comparative example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Success method
$http.get(&#39;&#39;).success(function(data) {
  $log.log(data);
});

// Then method
$http.get(&#39;&#39;).then(function(response) {
  $log.log(response.data); // &amp;lt;&amp;lt;&amp;lt; See the difference?
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second difference is that unlike &lt;code&gt;then&lt;/code&gt;, neither &lt;code&gt;success&lt;/code&gt; nor &lt;code&gt;error&lt;/code&gt; will create and return new promises. The promise they return is the same HTTP promise from &lt;code&gt;$http.get()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Overall, I&amp;rsquo;d recommend not using &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt;, but adopting &lt;code&gt;then&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt;. The latter can be found in other Promise libraries, and is already evolved to be a convention.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The usage of a deferred object to resolve and reject promises can be replaced by a simplified style:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Returning a value in success or error callbacks resolves the promise with the returned value.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Returning a rejected promise using &lt;code&gt;return $q.reject(something)&lt;/code&gt; rejects the promise.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Prefer using catch to provide error callbacks. Change &lt;code&gt;.catch&lt;/code&gt; to &lt;code&gt;[&#39;catch&#39;]&lt;/code&gt; in IE8.&lt;/p&gt;

&lt;p&gt;Stop using &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Angular Tutorial Videos</title>
      <link>http://davidcai.github.io/blog/posts/angular-tutorials/</link>
      <pubDate>Thu, 10 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://davidcai.github.io/blog/posts/angular-tutorials/</guid>
      <description>

&lt;p&gt;Here is my collection of free tutorial videos. Could be really helpful for people new to Angular.&lt;/p&gt;

&lt;h1 id=&#34;1-shaping-up-with-angular-js&#34;&gt;1. Shaping up with Angular JS&lt;/h1&gt;

&lt;p&gt;Gregg Pollack&amp;rsquo;s &amp;ldquo;Shaping up with Angular.js&amp;rdquo; from codeschool.com has been there for a while. It is one of the tutorials that have the best intro. The series covers Angular setup, binding, controllers, directives, filters, form handling, and services. The best part is its challenges after each chapter.&lt;/p&gt;

&lt;p&gt;&lt;a class=&#34;img-og&#34; href=&#34;http://campus.codeschool.com/courses/shaping-up-with-angular-js/intro&#34; target=&#34;_blank&#34;&gt;
  &lt;img src=&#34;http://projector.codeschool.com/videos/6ab6e1ab/thumbnail&#34;&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The tutorial might be a bit confusing to navigate. Make sure you scroll all the way to the top, and click the &amp;ldquo;START COURSE&amp;rdquo; button, which will list all the chapters. It&amp;rsquo;s recommended starting from the beginning in the order. The tutorial walks you through building a gem store project. Skipping the previous chapters might make yourself lost.&lt;/p&gt;

&lt;p&gt;At the bottom right corner, you will find the &amp;ldquo;START CHALLENGES&amp;rdquo; button which brings you to the exercises. The challenge mode gives you an inline editor to play around the code. Your editing will be immediately reflected in the &amp;ldquo;Preview&amp;rdquo; panel. Pretty handy for learn by play.&lt;/p&gt;

&lt;p&gt;The tutorial has a sequel &amp;ndash; &amp;ldquo;Staying Sharp with Angular.js&amp;rdquo;. Alyssa Nicoll will be your mentor. The first chapter covers router. It is free. The following chapters might need payment to unlock.&lt;/p&gt;

&lt;p&gt;Free tutorial: &lt;a href=&#34;http://campus.codeschool.com/courses/shaping-up-with-angular-js/intro&#34;&gt;Shaping up with Angular.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Sequel: &lt;a href=&#34;https://www.codeschool.com/courses/staying-sharp-with-angular-js&#34;&gt;Staying Sharp with Angular.js&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;2-egghead-io-new-to-angular-js&#34;&gt;2. Egghead IO - New to Angular JS?&lt;/h1&gt;

&lt;p&gt;Egghead is famous of its bite-sized videos. Each video can be consumed within 10 min. The entire tutorial is very easy to navigate. The noteworthy is that each short clip has its own discussion section. You might very well learn something new from these informative discussions.&lt;/p&gt;

&lt;p&gt;&lt;a class=&#34;img-og&#34; href=&#34;https://egghead.io/articles/new-to-angularjs-start-learning-here?utm_content=buffer3b17a&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer&#34; target=&#34;_blank&#34;&gt;
  &lt;img src=&#34;http://www.infragistics.com/community/cfs-file.ashx/__key/CommunityServer.Blogs.Components.WeblogFiles/brent_5F00_schooley.metablogapi/2061.logo_5F00_3309A602.png&#34;&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This tutorial spent a lot of inks on directives and isolated scopes, which are essential to writing better components in Angular JS.&lt;/p&gt;

&lt;p&gt;Egghead.io is a powerhouse for all Angular learning. If you&amp;rsquo;d like to adventure to specific topics or advanced usage, check out this list of &lt;a href=&#34;https://egghead.io/technologies/angularjs&#34;&gt;all Angular lessons&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Egghead.io: &lt;a href=&#34;https://egghead.io/articles/new-to-angularjs-start-learning-here?utm_content=buffer3b17a&amp;amp;utm_medium=social&amp;amp;utm_source=twitter.com&amp;amp;utm_campaign=buffer&#34;&gt;New to AngularJS?&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;3-angular-youtube-channel&#34;&gt;3. Angular Youtube Channel&lt;/h1&gt;

&lt;p&gt;For people who prefer picking their own lessons, Angular&amp;rsquo;s Youtube channel is the gold mine.&lt;/p&gt;

&lt;p&gt;&lt;a class=&#34;img-og&#34; href=&#34;https://www.youtube.com/user/angularjs&#34; target=&#34;_blank&#34;&gt;
  &lt;img src=&#34;http://codegeekz.com/wp-content/uploads/AngularJS-YouTube.jpeg&#34;&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Strictly speaking, the channel itself is not a tutorial site, however, here, you will find great videos covering wide range of topics. I will give you some examples:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Julie Ralph&amp;rsquo;s video on Angular &lt;a href=&#34;https://www.youtube.com/watch?v=vvxsWokQblk&#34;&gt;Protractor test&lt;/a&gt; and &lt;a href=&#34;https://www.youtube.com/watch?v=BvAeabvZ61o&#34;&gt;more&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Vojta Jina&amp;rsquo;s &lt;a href=&#34;https://youtu.be/rB5b67Cg6bc&#34;&gt;Testing Directives&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/dF_ObGgzGE8&#34;&gt;Reusable Components in Angular: Design patterns, transclusion, and more&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Youtube &lt;a href=&#34;https://www.youtube.com/user/angularjs&#34;&gt;Angular channel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Other Youtube channels related to Angular JS:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/channel/UCm9iiIfgmVODUJxINecHQkA&#34;&gt;ng-conf channel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/channel/UCBWXtgwaUqyvI50euTYlUWQ&#34;&gt;Angular U channel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;4-others&#34;&gt;4. Others&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;PluralSight.com &lt;a href=&#34;http://www.pluralsight.com/search/?searchTerm=angular&#34;&gt;Angular courses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/UlvCbnKAH3g&#34;&gt;John Papa - 10 AngularJS Patterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;David Mosher&amp;rsquo;s &lt;a href=&#34;https://www.youtube.com/watch?v=Ty8XcASK9js&#34;&gt;Advanced Directives&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Now, some silly stuff &lt;a href=&#34;https://youtu.be/M_Wp-2XA9ZU&#34;&gt;ng-wat&lt;/a&gt; inspired by &lt;a href=&#34;https://youtu.be/FqhZZNUyVFM&#34;&gt;JS Wat&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Angular: Copy vs. Extend vs. Merge</title>
      <link>http://davidcai.github.io/blog/posts/copy-vs-extend-vs-merge/</link>
      <pubDate>Wed, 09 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://davidcai.github.io/blog/posts/copy-vs-extend-vs-merge/</guid>
      <description>

&lt;p&gt;Copy, extend, and merge are parts of the utility functions come with Angular. This post explores their differences.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;copy&#34;&gt;Copy&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;angular.copy&lt;/code&gt; is a &lt;em&gt;deep&lt;/em&gt; copy.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var o1 = { name: &#39;David&#39;, age: 26, skill: {} };
var o2 = angular.copy(o1);

console.log(o2);
// Output: { name: &#39;David&#39;, age: 26, skill: {} }

console.log(o1 === o2);
// Output: false

console.log(o1.skill === o2.skill);
// Output: false
// o2.skill is a copy of o1.skill. They don&#39;t point to the same skill object.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;extend&#34;&gt;Extend&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;angular.extend(dst, src1, src2, ...)&lt;/code&gt; is to &lt;em&gt;shallow&lt;/em&gt; copy the properties of the source objects from right to left, all the way to the destination object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var src1 = { name: &#39;David&#39;, age: 30 }; // source 1
var src2 = { age: 26, skill: {} }; // source 2
var dst = {}; // destination

console.log(angular.extend(dst, src1, src2));
// Output: { name: &#39;David&#39;, age: 26, skill: {} }

console.log(src2.skill === dst.skill);
// Output: true
// src2 and dst share the same skill object due to shallow copy.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;merge&#34;&gt;Merge&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;angular.merge&lt;/code&gt; is an Angular 1.4+ API that is to &lt;em&gt;deep&lt;/em&gt; (recursively) copy the properties of the source objects to the destination object.&lt;/p&gt;

&lt;p&gt;Here we use the above example, and replace &lt;code&gt;angular.extend&lt;/code&gt; with &lt;code&gt;angular.merge&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var src1 = { name: &#39;David&#39;, age: 30 };
var src2 = { age: 26, skill: {} };
var dst = {};

console.log(angular.merge(dst, src1, src2));
// Output: { name: &#39;David&#39;, age: 26, skill: {} }
// It seems to the same result as the previous example&#39;s, however, ...

console.log(src2.skill === dst.skill);
// Output: false
// src2.skill and dst.skill point to different skill objects due to deep copy.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;more-extend-vs-merge&#34;&gt;More Extend vs. Merge&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;angular.copy&lt;/code&gt; is simply to clone an object. &lt;code&gt;angular.extend&lt;/code&gt; and &lt;code&gt;angular.merge&lt;/code&gt; are more interesting. Here is another set of comparing examples.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;angular.extend&lt;/code&gt; &amp;ndash; shallow copy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var src1 = { skill: { name: &#39;Java&#39;, experience: 20, certified: true } };
var src2 = { skill: { name: &#39;JavaScript&#39;, experience: 10 } };
var dst = {};

console.log(angular.extend(dst, src1, src2));
// Output: { skill: { name: &#39;JavaScript&#39;, experience: 10 } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;certified: true&lt;/code&gt; is lost. Because of shallow copy, the skill property is &lt;em&gt;assigned&lt;/em&gt; from src2 to src1 without &lt;em&gt;recursively&lt;/em&gt; copying the individual properties inside the skill value.&lt;/p&gt;

&lt;p&gt;The same code yields totally different result if we replace &lt;code&gt;extend&lt;/code&gt; with &lt;code&gt;merge&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;angular.merge&lt;/code&gt; &amp;ndash; deep (recursive) copy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var src1 = { skill: { name: &#39;Java&#39;, experience: 20, certified: true } };
var src2 = { skill: { name: &#39;JavaScript&#39;, experience: 10 } };
var dst = {};

console.log(angular.merge(dst, src1, src2));
// Output: { skill: { name: &#39;JavaScript&#39;, experience: 10, certified: true } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With &lt;code&gt;angular.merge&lt;/code&gt;, properties are recursively copied from src2 to src1, so &lt;code&gt;certified: true&lt;/code&gt; is reserved.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;user-and-default-options&#34;&gt;User and Default Options&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;angular.extend&lt;/code&gt; or &lt;code&gt;angular.merge&lt;/code&gt; is often used to achieve user options overriding default options. Here is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function orderDrink(options) {

  // Default options
  var defaultOptions = { size: &#39;medium&#39; };

  // Supplied options override default options
  var opts = angular.extend({}, defaultOptions, options);

  console.log(opts.size);
}

orderDrink({ size: &#39;large&#39; }); // Output: &#39;large&#39;
orderDrink(); // Output: &#39;medium&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more complicate case that has nested options, you might want to use &lt;code&gt;angular.merge&lt;/code&gt; for its deep copy.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Simple A/B Testing Service</title>
      <link>http://davidcai.github.io/blog/posts/a-simple-ab-testing-service/</link>
      <pubDate>Sun, 16 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://davidcai.github.io/blog/posts/a-simple-ab-testing-service/</guid>
      <description>&lt;p&gt;A very simple A/B testing service implemented in Angular &amp;ndash; abTestService:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;;(function() {
  &#39;use strict&#39;;

  angular
    .module(&#39;abTest&#39;, [])
    .factory(&#39;abTestService&#39;, abTestService)
  ;


  function abTestService() {
    return {
      pick: pick
    };

    function pick() {
      var i = Math.floor(Math.random() * arguments.length);
      return arguments[i];
    }
  }

})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;abTestService has only one method &amp;ndash; pick, which is to evenly pick one from many choices:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// a or b. 50% vs 50% chances
abTestService.pick(&#39;a&#39;, &#39;b&#39;);

// apple or orange. 50% vs 50%
abTestService.pick(&#39;apple&#39;, &#39;orange&#39;);

// a, b, or c. 1/3 vs 1/3 vs 1/3
abTestService.pick(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);

// a or b. 2/3 vs 1/3
abTestService.pick(&#39;a&#39;, &#39;a&#39;, &#39;b&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is an example of how to use abTestService with UI Router:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;;(function() {
  &#39;use strict&#39;;

  angular
    .module(&#39;myApp&#39;, [
      &#39;abTest&#39;,
      &#39;ui.router&#39;
    ])
    .config(configRoute)
  ;


  function configRoute($stateProvider) {
    $stateProvider.state(&#39;home&#39;, {
      url: &#39;/&#39;,
      templateProvider: function(abTestService) { // Inject abTestService
        var result = abTestService.pick(&#39;a&#39;, &#39;b&#39;); // Pick a or b

        // home-a.html or home-b.html
        return &#39;&amp;lt;div ng-include=&amp;quot;\&#39;app/home-&#39; + result + &#39;.html\&#39;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#39;;
      }
    });
  }

})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To better explain the logic behind templateProvider, I created this &lt;a href=&#34;http://davidcai.github.io/blog/posts/router-dynamic-templates/&#34;&gt;post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Router: Dynamic Templates</title>
      <link>http://davidcai.github.io/blog/posts/router-dynamic-templates/</link>
      <pubDate>Sat, 15 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://davidcai.github.io/blog/posts/router-dynamic-templates/</guid>
      <description>

&lt;p&gt;This post discusses how to create dynamic templates by leveraging the templateProvider configuration provided by Angular&amp;rsquo;s built-in router or the third-party UI Router.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;problem&#34;&gt;PROBLEM&lt;/h2&gt;

&lt;p&gt;For Single Page Applications (SPAs), we often need to switch views or states inside containers. This is usually done through routers. With either Angular&amp;rsquo;s built-in router or the popular UI Router, we are able to define the relationship between states and their templates. For instance, here we defined a state &lt;code&gt;home&lt;/code&gt; and its template URL &lt;code&gt;app/home/home.html&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;app.config(function($stateProvider) {
  $stateProvider.state(&#39;home&#39;, {
    url: &#39;/&#39;,
    templateUrl: &#39;app/home/home.html&#39;
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In some cases, this state-to-template relationship can not be determined beforehand at the &lt;code&gt;config&lt;/code&gt; time. The decision of what the template or template URL will be used for a state has to wait for the availability of run-time data. For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;User&amp;rsquo;s account type, e.g. show Home version A for members, and version B for public users.&lt;/li&gt;
&lt;li&gt;A/B testing, e.g. a A/B testing service randomly picks from two versions &amp;ndash; A or B.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In either scenario, the template cannot be fixed to &lt;code&gt;app/home/home.html&lt;/code&gt;, and has be to resolved using run-time data.&lt;/p&gt;

&lt;p&gt;Router&amp;rsquo;s &lt;code&gt;templateUrl&lt;/code&gt; configuration accepts a function which can be used to create dynamic template URL. However, we are not able to inject run-time dependencies (e.g. user services, or A/B test services) into the templateUrl function. The only available argument of the &lt;code&gt;templateUrl&lt;/code&gt; function is &lt;code&gt;$stateParams&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$stateProvider.state(&#39;home&#39;, {
  templateUrl: function($stateParams) { // Can not inject dependencies
    return &#39;app/home.&#39; + $stateParams.option + &#39;.html&#39;;
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;SOLUTION&lt;/h2&gt;

&lt;p&gt;The answer is &lt;code&gt;templateProvider&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Both Angular built-in router and the UI Router have a &lt;code&gt;templateProvider&lt;/code&gt; configuration. &lt;code&gt;templateProvider&lt;/code&gt; accepts a function that can be injected with run-time dependencies.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$stateProvider.state(&#39;home&#39;, {
  templateProvider: function(abTestService) { // abTestService is injected here
    var result = abTestService.pick(&#39;a&#39;, &#39;b&#39;); // Choose version A or B
    return &#39;...&#39;; // Return template content based on the result
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;templateProvider&lt;/code&gt; returns template content (not an URL to the template). We can certainly embed HTML markups directly in JavaScript, but for complicate HTML, it&amp;rsquo;s better to externalize the HTML content to separate template files. Here, we created &lt;code&gt;home-a.html&lt;/code&gt; and &lt;code&gt;home-b.html&lt;/code&gt;, and &lt;code&gt;ngInclude&lt;/code&gt; them in the templateProvider function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- Home version A at app/home/home-a.html --&amp;gt;
&amp;lt;div ng-controller=&amp;quot;HomeAController&amp;quot;&amp;gt;Version A&amp;lt;/div&amp;gt;

&amp;lt;!-- Home version B at app/home/home-b.html --&amp;gt;
&amp;lt;div ng-controller=&amp;quot;HomeBController&amp;quot;&amp;gt;Version B&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$stateProvider.state(&#39;home&#39;, {
  templateProvider: function(abTestService) {
    var result = abTestService.pick(&#39;a&#39;, &#39;b&#39;);

    // ngInclude template content based on the A/B test result
    return &#39;&amp;lt;div ng-include=&amp;quot;\&#39;app/home/home-&#39; + result + &#39;.html\&#39;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#39;;
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;templateProvider&lt;/code&gt; can also return a Promise which is resolved to template content.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$stateProvider.state(&#39;home&#39;, {
  templateProvider: function($http, USER_SERVICE_REST_URL) {

    // Here, we return a promise instead of the template content
    return $http.get(USER_SERVICE_REST_URL).then(function(data) {
      var result = (data.type === &#39;member&#39; ? &#39;a&#39; : &#39;b&#39;);

      // Return the template content
      return &#39;&amp;lt;div ng-include=&amp;quot;\&#39;app/home/home-&#39; + result + &#39;.html\&#39;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#39;;
    });
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;even-better-solution&#34;&gt;EVEN BETTER SOLUTION&lt;/h2&gt;

&lt;p&gt;Having &lt;code&gt;ngInclude&lt;/code&gt; in &lt;code&gt;templateProvider&lt;/code&gt; function feels still a bit hackish to me. The ideal solution is to specify a template URL, and then let Angular fetch the content. However, sending separate HTTP requests just to fetch templates seems to be unnecessary web traffic. It will be better if the template content can be cached in the $templateCache service; and then, all I need to do is &lt;code&gt;$templateCache.get(&#39;templateUrl&#39;)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$stateProvider.state(&#39;home&#39;, {
  templateProvider: function(abTestService, $templateCache) {
    var result = abTestService.pick(&#39;a&#39;, &#39;b&#39;);

    // Retrieve the cached template content from $templateCache service
    return $templateCache.get(&#39;app/home/home-&#39; + result + &#39;.html&#39;);
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To achieve this, we need a Gulp task to convert all HTML files under the app/ directory to JavaScript strings, and save the strings in $templateCache.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Load gulp and its plugins
var gulp = require(&#39;gulp&#39;);
var minifyHtml = require(&#39;gulp-minify-html&#39;);
var angularTemplateCache = require(&#39;gulp-angular-templatecache&#39;);


gulp.task(&#39;templates&#39;, function() {

  return cacheTemplates(&#39;src/app/**/*.html&#39;, &#39;app.template.js&#39;);

  function cacheTemplates(input, output) {
    return gulp.src(input) // Get all HTML files
      .pipe(minifyHtml({ // Minify HTML content first
        empty: true,
        spare: true,
        quotes: true
      }))
      .pipe(angularTemplateCache(output, { // Save minified strings to cache
        module: &#39;myApp&#39; // Setup $templateCache for Angular module &#39;myApp&#39;
      }))
      .pipe(gulp.dest(&#39;.tmp/templates/&#39;));

  } // /function cacheTemplates

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, import the generated &lt;code&gt;template.js&lt;/code&gt; in &lt;code&gt;index.html&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&amp;quot;.tmp/templates/app.template.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;CONCLUSION&lt;/h2&gt;

&lt;p&gt;By leveraging the &lt;code&gt;templateProvider&lt;/code&gt; function that can be injected with dependencies, we are able to resolve template content based on run-time data. This technique is useful for switching among more than one templates for a state, for instance, A/B testing, and swappable content in limited space.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Directive Isolated Scope: @ vs. =</title>
      <link>http://davidcai.github.io/blog/posts/directive-at-vs-equal/</link>
      <pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://davidcai.github.io/blog/posts/directive-at-vs-equal/</guid>
      <description>

&lt;p&gt;Shall I use @ or = to bind scope variables? Their difference is very well explained in Angular&amp;rsquo;s documentation. However, this question still often pops up when I create directives. In this post, I listed some of the major differences between these two.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;interpolation-binding&#34;&gt;@: Interpolation Binding&lt;/h2&gt;

&lt;p&gt;&amp;rdquo;@&amp;rdquo; symbols can be used to bind interpolations. Interpolations are {{ }} expressions.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say we have a @-bound scope variable &amp;ndash; &lt;code&gt;name&lt;/code&gt; in a directive:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// A directive
function awesomeWidget() {
  return {
    ...
    scope: {
      name: &#39;@&#39; // @-bound variable
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now can assign interpolation &lt;code&gt;{{ person.name }}&lt;/code&gt; to the @-bound variable &lt;code&gt;name&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- Use interpolation {{ person.name }} for @-bound variables --&amp;gt;
&amp;lt;awesome-widget name=&amp;quot;{{ person.name }}&amp;quot;&amp;gt;&amp;lt;/awesome-widget&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, what will happen if we replace &lt;code&gt;{{ person.name }}&lt;/code&gt; with &lt;code&gt;person.name&lt;/code&gt;? Angular will not throw any error, but the value of &lt;code&gt;scope.name&lt;/code&gt; will be a &lt;code&gt;&#39;person.name&#39;&lt;/code&gt; string instead of the real value of person.name.&lt;/p&gt;

&lt;p&gt;We can also assign primitives (string, number, boolean, and etc.) directly to @-bound values. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;awesome-widget name=&amp;quot;David&amp;quot; age=&amp;quot;26.5&amp;quot; single=&amp;quot;false&amp;quot;&amp;gt;&amp;lt;/awesome-widget&amp;gt;
&amp;lt;!-- Note: &amp;quot;David&amp;quot; here is a string primitive not a variable name --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Angular is smart enough to figure out their types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function awesomeWidget($log) {
  return {
    ...
    scope: {
      name: &#39;@&#39;, age: &#39;@&#39;, single: &#39;@&#39;
    },
    link: function(scope) {
      $log.log(scope.name, typeof scope.name);
      // --&amp;gt; &amp;quot;David&amp;quot;, string
      $log.log(scope.age, typeof scope.age);
      // --&amp;gt; 26.5, number
      $log.log(scope.single, typeof scope.single);
      // --&amp;gt; false, boolean
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;variable-name-binding&#34;&gt;=: Variable Name Binding&lt;/h2&gt;

&lt;p&gt;&amp;rdquo;=&amp;rdquo; symbols can be used to bind variable names.&lt;/p&gt;

&lt;p&gt;Here, we have a =-bound variable &amp;ndash; &lt;code&gt;name&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function awesomeWidget() {
  return {
    ...
    scope: {
      name: &#39;=&#39; // =-bound scope variable
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unlike @-bound variables which require interpolations such as &lt;code&gt;{{ person.name }}&lt;/code&gt;, =-bound variables can directly refer to variable names, e.g. &lt;code&gt;person.name&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;awesome-widget name=&amp;quot;person.name&amp;quot;&amp;gt;&amp;lt;/awesome-widget&amp;gt;
&amp;lt;!-- Not {{ person.name }} --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we replace &lt;code&gt;person.name&lt;/code&gt; with &lt;code&gt;{{ person.name }}&lt;/code&gt;, Angular will throw an error this time:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;Error: [$parse:syntax] Syntax Error:
Token &#39;{&#39; invalid key at column 2 of the expression [{{ person.name }}]
starting at [{ person.name }}].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Primitives can also be assigned to =-bound variables. For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;awesome-widget age=&amp;quot;26.5&amp;quot; single=&amp;quot;false&amp;quot;&amp;gt;&amp;lt;/awesome-widget&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, for strings, single quotes are needed. This is different from @-bound values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;awesome-widget name=&amp;quot;&#39;David&#39;&amp;quot;&amp;gt;&amp;lt;/awesome-widget&amp;gt;
&amp;lt;!-- Note: David is wrapped in single quotes --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The single quotes are needed because without the single quotes, Angular will treat &amp;ldquo;David&amp;rdquo; as a variable name instead of a string primitive, which might not be what you wanted.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;one-way-binding&#34;&gt;@: One-way Binding&lt;/h2&gt;

&lt;p&gt;@ is for one-way binding - the bound value is passed into a directive&amp;rsquo;s scope, however, any change made to the value inside the directive will not be passed back from the directive. To help myself remember this syntax, I&amp;rsquo;d like to think @ as &amp;lsquo;point at&amp;rsquo; - a one-way direction - from the external scope to a directive&amp;rsquo;s internal scope.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div ng-controller=&amp;quot;MainController&amp;quot;&amp;gt;
  &amp;lt;awesome-widget name=&amp;quot;{{ person.name }}&amp;quot;&amp;gt;&amp;lt;/awesome-widget&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We bind &lt;code&gt;{{ person.name }}&lt;/code&gt; to the directive through the &lt;code&gt;name&lt;/code&gt; attribute. The value of &lt;code&gt;person.name&lt;/code&gt; comes from a person object that is attached to the &lt;code&gt;MainController&lt;/code&gt;&amp;rsquo;s scope:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// A controller
function MainController($scope) {
  $scope.person = { name: &#39;David&#39; };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the directive, the @ symbol is to indicate that &lt;code&gt;name&lt;/code&gt; will be one-way bound to the directive&amp;rsquo;s scope variable &lt;code&gt;scope.name&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// A directive
function awesomeWidget() {
  return {
    ...
    scope: {
      name: &#39;@&#39; // One-way binding
    },
    link: function(scope) {
      // Here we change the name variable on the directive scope
      scope.name = &#39;Serena&#39;;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we change the name variable inside the directive (e.g., in the link function), the changed name will not be passed back from the directive&amp;rsquo;s scope to the controller&amp;rsquo;s scope.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div ng-controller=&amp;quot;MainController&amp;quot;&amp;gt;
  &amp;lt;awesome-widget name=&amp;quot;{{ person.name }}&amp;quot;&amp;gt;&amp;lt;/awesome-widget&amp;gt;

  &amp;lt;!-- In the controller&#39;s scope, person.name will still be &amp;quot;David&amp;quot; instead of &amp;quot;Serena&amp;quot; --&amp;gt;
  {{ person.name }}
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inside awesome-widget&amp;rsquo;s &lt;code&gt;link&lt;/code&gt; function, name is changed from &amp;ldquo;David&amp;rdquo; to &amp;ldquo;Sereana&amp;rdquo;. However, outside of the directive, &lt;code&gt;person.name&lt;/code&gt; is still &amp;ldquo;David&amp;rdquo;. This is because the scope variable &lt;code&gt;name&lt;/code&gt; is one-way bound. The change will not affect the scope outside of its directive.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;two-way-binding&#34;&gt;=: Two-way Binding&lt;/h2&gt;

&lt;p&gt;= is for two-way binding, meaning the change made to the bound value will be &amp;ldquo;sync&amp;rsquo;d&amp;rdquo; both inside and outside of a directive. I&amp;rsquo;d like to think the &amp;ldquo;=&amp;rdquo; symbol as &amp;ldquo;bi-directional&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Using the above example, we change &amp;ldquo;@&amp;rdquo; to &amp;ldquo;=&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// A directive
function awesomeWidget() {
  return {
    ...
    scope: {
      name: &#39;=&#39; // Changed to two-way binding
    },
    link: function(scope) {
      scope.name = &#39;Serena&#39;;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that in the HTML template, we also changed &lt;code&gt;{{ person.name }}&lt;/code&gt; to &lt;code&gt;person.name&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div ng-controller=&amp;quot;MainController&amp;quot;&amp;gt;
  &amp;lt;awesome-widget name=&amp;quot;person.name&amp;quot;&amp;gt;&amp;lt;/awesome-widget&amp;gt; &amp;lt;!-- Removed {{ }} --&amp;gt;

  &amp;lt;!-- Now, person.name is changed to &amp;quot;Serena&amp;quot; --&amp;gt;
  {{ person.name }}
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The scope variable &lt;code&gt;name&lt;/code&gt; is changed in directive&amp;rsquo;s &lt;code&gt;link&lt;/code&gt; function. Because &lt;code&gt;name&lt;/code&gt; is two-way bound, the change is also reflected in &lt;code&gt;person.name&lt;/code&gt; on &lt;code&gt;MainControler&lt;/code&gt;&amp;rsquo;s scope.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Type&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Direction&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Value type&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;String primitive&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;One-way binding&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Interpolations and primitives&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;No single quote: &amp;ldquo;David&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;=&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Two-way binding&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Variable names and primitives&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Single quotes: &amp;ldquo;&amp;lsquo;David&amp;rsquo;&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Angular Factory Pattern</title>
      <link>http://davidcai.github.io/blog/posts/angular-factory-pattern/</link>
      <pubDate>Wed, 05 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://davidcai.github.io/blog/posts/angular-factory-pattern/</guid>
      <description>

&lt;h2 id=&#34;suffix-factory-with-service&#34;&gt;Suffix Factory with &amp;lsquo;Service&amp;rsquo;&lt;/h2&gt;

&lt;p&gt;The terminology &amp;ldquo;Factory&amp;rdquo; in Angular is different from the one used in the Java community. From a Java developer&amp;rsquo;s perspective, a factory is to create something by a specification supplied by the factory caller. There should be only one public method on a factory - getInstance(). Well, maybe some variations of the getInstance method. But that should be it. Factories simply create stuff.&lt;/p&gt;

&lt;p&gt;However, in Angular, unlike &lt;code&gt;angular.controller&lt;/code&gt; which creates a controller, what &lt;code&gt;angular.factory&lt;/code&gt; creates is not a factory but a service - a place to host public APIs and encapsulate logics, not a factory that creates stuff. Services certainly could be used to create things, however, the most common usage is to wrap shared code and expose them to consumer code.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;angular.factory&lt;/code&gt; returns a service singleton. That&amp;rsquo;s why I would like to suffix the factory function with &amp;ldquo;Service&amp;rdquo; not &amp;ldquo;Factory&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;angular
  .module(&#39;myApp&#39;)
  // userService instead of userFactory
  .factory(&#39;userService&#39;, userService)
;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;decouple-interface-from-implementation&#34;&gt;Decouple Interface from Implementation&lt;/h2&gt;

&lt;p&gt;A common factory looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//
// Not so good
//
angular
  .module(&#39;myApp&#39;)
  .factory(&#39;userService&#39;, userService)
;

function userService($http, $log) {

  // Private variables
  var REST_URL = &#39;/api/users&#39;;

  // Return the service instance
  return {

    // Public methods

    getUsers: function() { ... },
    queryUsers: function(by) { ... }
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing is really wrong with the above example. However, there is room for improvement - the returned service instance is a congealment of both interface and implementation. &lt;code&gt;getUsers&lt;/code&gt; and &lt;code&gt;queryUsers&lt;/code&gt; are interfaces, while their associated anonymous functions are implementation details. If the anonymous functions grow in lines of code, it would be &amp;ldquo;a bit&amp;rdquo; difficult to tell the service interface from implementations. To improve the readability, a common practice is to move the implementations out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//
// Better
//
function userService($http, $log) {

  ...

  // Move implementation here
  var getUsers = function() { ... };
  var queryUsers = function(by) { ... };

  // Keep interface simple
  return {
    getUsers: getUsers
    queryUsers: queryUsers
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;move-declarations-to-top&#34;&gt;Move Declarations to Top&lt;/h2&gt;

&lt;p&gt;To push good readability further, I will move declarations above implementations, just like how we define Angular components. Here is an example of Angular controller definition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//
// Good example
//
angular
  .module(&#39;myApp&#39;)
  // Controller declarations. We have two controllers
  .controller(&#39;MainController&#39;, MainController)
  .controller(&#39;SideBarController&#39;, SideBarController)
;

// Controller implementations
function MainController() { ... }
function SideBarController() { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By moving declarations above Implementations, we have a clear manifest of what this Angular script will do. Apply the same principle to factories:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//
// Improved
//
function userService($http) {

  // Declarations, moved up.
  return {
    getUsers: getUsers,
    queryUsers: queryUsers
  };

  // Implementations, moved down.
  // Use function declaration syntax instead of
  // var getUsers = function() { ... };
  function getUsers() { ... }
  function queryUsers(by) { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we use function declaration syntax to define the implementation functions, so they will be hoisted and accessible even before they are defined.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also recommended to have variables defined at top of the function body:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//
// Improved
//
function userService($http) {

  // Declarations
  var var1 = 1;

  return {
    getUsers: getUsers,
    queryUsers: queryUsers
  };

  // Implementations
  function getUsers() { ... }
  function queryUsers(by) { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Suffix factories with &amp;lsquo;Service&amp;rsquo;. Leverage function hoisting to pull declarations above implementations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;;(function() {
  &#39;use strict&#39;;

  angular
    .module(&#39;myApp&#39;)
    .factory(&#39;userService&#39;, userService) // Declaration
  ;


  function userService($http, $log) { // Implementation

    // Declaration

    var REST_URL = &#39;/api/users&#39;;

    return {
      getUsers: getUsers,
      queryUsers: queryUsers
    };

    // Implementation

    function getUsers() { ... }

    function queryUsers(by) { ... }
  }

})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same style can be applied to other Angular components, such as directives and filters. Here is a directive example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;;(function() {
  &#39;use strict&#39;;

  angular
    .module(&#39;myApp&#39;)
    .directive(&#39;myAwesomeWidget&#39;, myAwesomeWidget)
  ;


  function myAwesomeWidget($log) {

    // Directive declarations
    return {
      restrict: &#39;AE&#39;,
      scope: {
        options: &#39;=&#39;
      },
      templateUrl: &#39;app/common/myAwesomeWidget.html&#39;,
      link: linkMyAwesomeWidget
    };

    // Link function implementation
    function linkMyAwesomeWidget(scope, elem, attrs) {
      ...
    }
  }
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Angular Best Practice Recap</title>
      <link>http://davidcai.github.io/blog/posts/angular-best-practice-recap/</link>
      <pubDate>Sat, 01 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://davidcai.github.io/blog/posts/angular-best-practice-recap/</guid>
      <description>

&lt;p&gt;I attended a great Angular training provided by OasisDigital the last week. Learned so many tips and best practices from Bill Odom and his team. While my memory is still fresh, I&amp;rsquo;d like to document the stuff I learned. So again, I use my blog as study notes. While I&amp;rsquo;m on the topic of Angular best practices, I also like to bring in some advices from John Papa, Shai Reznik, and other wisdoms of the community. This article basically is a recap of what I heard and learned.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;prefer-factory-over-service&#34;&gt;PREFER FACTORY OVER SERVICE&lt;/h2&gt;

&lt;p&gt;A service is a simplified version of a factory. Services are a constructor functions. However, I&amp;rsquo;ve seen some service code that returns objects. The author of the code probably mistook services with factories. To clear the confusion, let&amp;rsquo;s favor factories over services. I personally prefer naming a factory as xyzService instead of xyzFactory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;angular
  .module(&#39;myApp&#39;)
  .factory(&#39;fooService&#39;, fooService)
;

function fooService() {
  return {
    getFoo: function() { ... },
    getBar: function() { ... }
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;assign-third-party-globals-to-values&#34;&gt;ASSIGN THIRD-PARTY GLOBALS TO VALUES&lt;/h2&gt;

&lt;p&gt;Although I can use $window to reference globals of third-party libraries, I like to assign globals to values, and inject them. This makes function arguments a clear contract of what dependencies my code requires.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;angular
  .module(&#39;myApp&#39;)
  .value(&#39;_&#39;, _) // lodash
  .value(&#39;d3&#39;, d3) // D3
;

...

function MainController(_, d3) { // Injection
  _.forEach( ... );
  d3.select( ... );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For low-level libraries (e.g., lodash), I can even delete lodash&amp;rsquo;s global &amp;lsquo;&lt;em&gt;&amp;rsquo; from the window object, so &amp;lsquo;&lt;/em&gt;&amp;rsquo; will be available only through injection:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;angular
  .module(&#39;myApp&#39;)
  .factory(&#39;_&#39;, function() {
    var _ = window._;
    delete window._; // Delete _ from window

    return _;
  })
;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;stick-with-http&#34;&gt;STICK WITH $HTTP&lt;/h2&gt;

&lt;p&gt;I feel $http gives me more flexibilities than $resource. And $http service&amp;rsquo;s promise interface is much nicer. Better to stick with $http than mixing $http and $resource which unnecessarily complicate my code.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;wrap-rest-in-services&#34;&gt;WRAP REST IN SERVICES&lt;/h2&gt;

&lt;p&gt;Encapsulate REST requests as methods in services, so users of the service don&amp;rsquo;t have to know the interface of your REST APIs, and the choice of REST libraries ($http, $resource, etc.).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;angular
  .module(&#39;myApp&#39;)
  .factory(&#39;accountService&#39;, accountService)
;

function accountService($http, $log) {
  return {
    getAccounts: function(userId) {
      return $http.get(&#39;/api/accounts/&#39; + userId)
        .then(function(response) {
          return response.data;
        })
        .catch(function(error) {
          $log.error(error);
          return error;
        })
      ;
    }
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ui-router-resolve-pattern&#34;&gt;UI ROUTER RESOLVE PATTERN&lt;/h2&gt;

&lt;p&gt;I often run to the scenarios where I need to hold off displaying UI until certain data is ready. The resolve property of uiRouter is designed to tackle this common problem.&lt;/p&gt;

&lt;p&gt;Assign a name-to-function map to the resolve property. If the function returns a value, the returned value is treated as dependency, and the value is injected into the controller; if the function returns a promise, the promise is resolved before the controller is instantiated, and the resolved value is injected into the controller.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$stateProvider
  .state(&#39;home&#39;, {
    ... ,

    // Resolve items and users before routing to the &#39;home&#39; state
    resolve: {
      items: function() {
        // Returns an array value
        return [
          { name: &#39;The Settlers of Catan&#39;, price: 51.46 },
          { name: &#39;Mansions of Madness&#39;, price: 56.52 }
        ];
      },
      users: function(userService) {
        // Returns a promise
        return userService.getUsers();
      }
    },

    // items and users are injected to the controller
    controller: function($scope, $log, items, users) {
      $log.log(items);
      $log.log(users);
    }
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;isolate-directive-scope&#34;&gt;ISOLATE DIRECTIVE SCOPE&lt;/h2&gt;

&lt;p&gt;Think Angular directives as re-usable functions, and its scope as the argument list of a function. In most cases, a directive shouldn&amp;rsquo;t assume the presence of data in the ancestor scopes or elements in the DOM. The scope (and the directive&amp;rsquo;s DOM attributes) should be the only place where a directive retrieves external information.&lt;/p&gt;

&lt;p&gt;Pass information to directives via element attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div data-browse-happy-banner
  data-ie-version=&amp;quot;8&amp;quot;
  data-on-dismiss=&amp;quot;bannerDismissed()&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then retrieve these information from the scope:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;angular
  .module(&#39;myApp&#39;)
  .directive(&#39;browseHappyBanner&#39;, browseHappyBanner)
;

function browseHappyBanner() {
  return {
    restrict: &#39;A&#39;,
    scope: { // Isolated scope
      ieVersion: &#39;@&#39;, // Pass ieVersion from data-ie-version attribute
      onDismiss: &#39;&amp;amp;&#39; // Pass onDismiss callback from data-on-dismiss attribute
    },
    template: &#39;&amp;lt;div&amp;gt; ... &amp;lt;a data-ng-click=&amp;quot;onClose()&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;&#39;,
    ... ,
    link: function(scope) {
      // Retrieve ieVersion from scope
      var iev = parseInt(scope.ieVersion, 10);
      ...
      scope.onClose = function() {
        // Invoke onDismiss callback from the scope
        scope.onDismiss();  
      };
    }
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;clean-template&#34;&gt;CLEAN TEMPLATE&lt;/h2&gt;

&lt;p&gt;If snippets in a template look like program, then you are doing it wrong. Templates need to be declarative, easy to understand for non-programmers. The best practice is to imagine your template is written by a web designer rather than a developer.&lt;/p&gt;

&lt;p&gt;Will a web designer understand the following template?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div data-ng-class=&amp;quot;{
  &#39;error&#39;: ((bFormSubmitted || PersonalInfoForm.DOBmonth.$dirty) &amp;amp;&amp;amp; PersonalInfoForm.DOBmonth.$invalid) ||
            ((bFormSubmitted || PersonalInfoForm.DOBday.$dirty) &amp;amp;&amp;amp; PersonalInfoForm.DOBday.$invalid) ||
            ((bFormSubmitted || PersonalInfoForm.DOByear.$dirty) &amp;amp;&amp;amp; PersonalInfoForm.DOByear.$invalid ) || errorMapResult.birthdate,
  &#39;success&#39;: (PersonalInfoForm.DOBmonth.$dirty &amp;amp;&amp;amp; !PersonalInfoForm.DOBmonth.$invalid) &amp;amp;&amp;amp;
              (PersonalInfoForm.DOBday.$dirty &amp;amp;&amp;amp; !PersonalInfoForm.DOBday.$invalid) &amp;amp;&amp;amp;
              (PersonalInfoForm.DOByear.$dirty &amp;amp;&amp;amp; !PersonalInfoForm.DOByear.$invalid )}&amp;quot;&amp;gt;
  ...
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Guess no. Even developer might have hard time to understand this. Move the logic to controller or service, so the template becomes clean:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div data-ng-class=&amp;quot;{ &#39;error&#39;: hasError, &#39;success&#39;: isSuccessful }&amp;quot;&amp;gt;
  ...
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;thin-controller&#34;&gt;THIN CONTROLLER&lt;/h2&gt;

&lt;p&gt;Make controller thin. Move logic to services and directives. This makes controller much easy to test.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;light-filter&#34;&gt;LIGHT FILTER&lt;/h2&gt;

&lt;p&gt;Filter tends to be called multiple times. So if you have a filter that does a lot of heavy lifting, it will drag down the performance of the entire app. Try to simplify the logic in filter. Use cache or memoization to improve the performance.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
angular
  .module(&amp;quot;myApp&amp;quot;)
  .filter(&amp;quot;heavyLifting&amp;quot;, heavyLifting) // A filter does heavy lifting stuff
;

function heavyLifting() {

  var doHeavyLifting = function() { ... }; // Complicate process

  // Use lodash&#39;s memoize function to cache the returned result for a specific input.
  // Future calls with the same input will return the cached result.
  return _.memoize(function(input) {
    return doHeavyLifting(input);
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More details on filter and memoization can be found &lt;a href=&#34;http://www.terrencewatson.com/2014/06/28/memoize/&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;named-functions&#34;&gt;NAMED FUNCTIONS&lt;/h2&gt;

&lt;p&gt;Use named functions whenever you can. When error occurs inside the named function, the function name will appear in the stack trace, which is really helpful for debugging.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Named function showToggle
$timeout(function showToggle() {
  angular.element(&#39;.toggle&#39;).css(&#39;display&#39;, &#39;block&#39;);
}, 1000);

// Named function greet
var greet = function greet(name) {
  console.log(&#39;Hello &#39; + name);
};

// Named controller
angular.module(&#39;myApp&#39;).controller(&#39;MyController&#39;, MyController);
function MyController() { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;scope-js-code-in-iife&#34;&gt;SCOPE JS CODE IN IIFE&lt;/h2&gt;

&lt;p&gt;This best practice is not limited to Angular. IIFE (Immediately-Invoked Function Expression) is often used to create scopes in which the variables and functions will not be leaked to outer scopes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;;(function() {
  ...
  var app = angular.module(&#39;myApp&#39;);
  ...
})();

console.log(app) // not defined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;pyramid-testing&#34;&gt;PYRAMID TESTING&lt;/h2&gt;

&lt;p&gt;Again this advice is not limited to Angular.&lt;/p&gt;

&lt;p&gt;Write more unit tests. Treat unit tests as front-line defense. Use e2e protractor tests as high-level tests for verifying critical happy and error paths.&lt;/p&gt;

&lt;p&gt;Martin Fowler discussed &lt;a href=&#34;http://martinfowler.com/bliki/TestPyramid.html&#34;&gt;Test pyramid&lt;/a&gt; in his blog.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://davidcai.github.io/blog/img/pyramid.png&#34; alt=&#34;Test Pyramid&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ng-model-dot-rule&#34;&gt;NG-MODEL DOT RULE&lt;/h2&gt;

&lt;p&gt;Misko Hevery in his presentation on Angular best practices coined the &lt;a href=&#34;https://www.youtube.com/watch?feature=player_detailpage&amp;amp;v=ZhfUv0spHCY#t=1758s&#34;&gt;dot rule&lt;/a&gt;. My over-simplified version is to bind objects instead of primitives to $scope, and always initialize the bound object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function MainController($scope) {
  $scope.something = {}; // Always initialize the bound objects

  $scope.person = {
    name: &#39;David Cai&#39;
  }; // Bind objects to $scope instead of $scope.name = &#39;David Cai&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the HTML template:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div ng-controller=&amp;quot;MainController&amp;quot;&amp;gt;
  &amp;lt;input ng-model=&amp;quot;person.name&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;one-component-per-file&#34;&gt;ONE COMPONENT PER FILE&lt;/h2&gt;

&lt;p&gt;Limit one Angular component (directive, service, controller, etc.) per JavaScript file. Make it easy to locate components, and keep files shorter.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;angular
  .module(&#39;myApp&#39;)
  .directive(&#39;myAwesomeWidget&#39;, function() { ... })

  // Don&#39;t.
  // We already defined a directive in this file.
  // Move the following directive to another file.
  .directive(&#39;myOtherAwesomeWidget&#39;, function() { ... })
;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;group-files-by-features&#34;&gt;GROUP FILES BY FEATURES&lt;/h2&gt;

&lt;p&gt;There are two schools of thoughts when it comes to organizing Angular files - grouping by types, and grouping by features. I prefer the latter for big projects. Much easier for navigation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;common
  - util.filter.js
  - util.filter.spec.js
action-panel
  - action-panel.directive.js
  - action-panel.directive.spec.js
  - action-panel.html
  - action-panel.scss
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;include-intention-in-file-names&#34;&gt;INCLUDE INTENTION IN FILE NAMES&lt;/h2&gt;

&lt;p&gt;.js can mean a lot of things in Angular apps. It makes the intention much clear when the file names contain .controller, .directive, .spec, .service, etc.&lt;/p&gt;

&lt;p&gt;Shai Reznik recommends using .ctrl for controllers, .drv for directives, .srv for services., .tpl for templates, and .test for unit tests. I prefer full names, e.g. .controller. I also feel that HTML files don&amp;rsquo;t need .tpl or .template, since in most cases, HTML files are templates. No need to explicitly call them out as templates.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;lint-javascript&#34;&gt;LINT JAVASCRIPT&lt;/h2&gt;

&lt;p&gt;Use jshint, JSCS, or even better - &lt;a href=&#34;http://eslint.org/&#34;&gt;eslint&lt;/a&gt; to lint javascript code. Integrate lint into the build process. Use editor plugins to bring lint warnings and errors right in front of developers&amp;rsquo;s eyes. I&amp;rsquo;ve been considering to create GIT hook to block git pushes if lint reports any warnings or errors.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;use-ng-annotate&#34;&gt;USE NG-ANNOTATE&lt;/h2&gt;

&lt;p&gt;Angular replies on the names of function arguments for dependency injection. However, JS minification will shorten argument names, which ruined Angular DI. To work around this issue, we either use the DI array syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// DI array syntax
app.controller(&#39;MainController&#39;, [&#39;$scope&#39;, &#39;$log&#39;, function($scope, $log) {
  ...
}]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; or assign dependencies to the $inject property:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// $inject syntax
MainController.$inject = [&#39;$scope&#39;, &#39;$log&#39;];
function MainController($scope, $log) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These workarounds look like patchwork to me. Not to mention that both are error prone where you have to maintain the dependency order in arrays.&lt;/p&gt;

&lt;p&gt;Here comes &lt;a href=&#34;https://github.com/olov/ng-annotate&#34;&gt;ngAnnotate&lt;/a&gt; - an Angular plugin that automatically inserts the DI array syntax in source code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// ngAnnotate will replace function($scope, $log) { ... } with
// [&#39;$scope&#39;, &#39;$log&#39;, function($scope, $log) { ... }]
app.controller(&#39;MainController&#39;, function($scope, $log) {
  ...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although ngAnnotate is quite smart to figure out where to annotate DI syntax, in some cases, ngAnnotate might miss the DI annotation for a function. You can prepend a function with &lt;code&gt;/*@ngInject*/&lt;/code&gt; to explicitly state that the function should get annotated.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;leverage-task-runners&#34;&gt;LEVERAGE TASK RUNNERS&lt;/h2&gt;

&lt;p&gt;Lint and ngAnnotate can be integrated in the build process by task runners such as Gulp.&lt;/p&gt;

&lt;p&gt;Use Gulp to automate:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JS lint - &lt;a href=&#34;https://github.com/adametry/gulp-eslint&#34;&gt;gulp-eslint&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ngAnnotate - &lt;a href=&#34;https://github.com/Kagami/gulp-ng-annotate&#34;&gt;gulp-ng-annotate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Sort angular files - &lt;a href=&#34;https://github.com/klei/gulp-angular-filesort&#34;&gt;gulp-angular-filesort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Convert HTML templates to JS strings in $templateCache - &lt;a href=&#34;https://github.com/miickel/gulp-angular-templatecache&#34;&gt;gulp-angular-templatecache&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>