<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on David Cai | Blog</title>
    <link>http://davidcai.github.io/blog/posts/</link>
    <description>Recent content in Posts on David Cai | Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 16 Aug 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://davidcai.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A Simple A/B Testing Service</title>
      <link>http://davidcai.github.io/blog/posts/a-simple-ab-testing-service/</link>
      <pubDate>Sun, 16 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://davidcai.github.io/blog/posts/a-simple-ab-testing-service/</guid>
      <description>&lt;p&gt;A very simple A/B testing service implemented in Angular &amp;ndash; abTestService:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;;(function() {
  &#39;use strict&#39;;

  angular
    .module(&#39;abTest&#39;)
    .factory(&#39;abTestService&#39;, abTestService)
  ;


  function abTestService() {
    return {
      pick: pick
    };

    function pick() {
      var len = arguments.length;
      if (len === 0) {
        return null;
      }

      // Random number from [0, 1)
      var res = Math.random();

      for (var i = 0; i &amp;lt; len; i++) {
        if (res &amp;lt; (1 / len) * (i + 1)) {
          return arguments[i];
        }
      }
    } // /function pick
  }

})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;abTestService has only one method &amp;ndash; pick, which is to evenly pick one from many choices:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// a or b. 50% vs 50% chances
abTestService.pick(&#39;a&#39;, &#39;b&#39;);

// apple or orange. 50% vs 50%
abTestService.pick(&#39;apple&#39;, &#39;orange&#39;);

// a, b, or c. 1/3 vs 1/3 vs 1/3
abTestService.pick(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);

// a or b. 2/3 vs 1/3
abTestService.pick(&#39;a&#39;, &#39;a&#39;, &#39;b&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is an example of how to use abTestService in UI Router:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;;(function() {
  &#39;use strict&#39;;

  angular
    .module(&#39;myApp&#39;, [&#39;abTest&#39;])
    .config(configRoute)
  ;


  function configRoute($stateProvider) {
    $stateProvider.state(&#39;home&#39;, {
      url: &#39;/&#39;,
      templateProvider: function(abTestService) { // Inject abTestService
        var result = abTestService.pick(&#39;a&#39;, &#39;b&#39;); // Pick a or b

        // home-a.html or home-b.html
        return &#39;&amp;lt;div ng-include=&amp;quot;\&#39;app/home-&#39; + result + &#39;.html\&#39;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#39;;
      }
    });
  }

})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To better understand the logic behind &lt;code&gt;templateProvider&lt;/code&gt;, I created this &lt;a href=&#34;posts/router-dynamic-templates/&#34;&gt;post&lt;/a&gt; to explain it.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Router: Dynamic Templates</title>
      <link>http://davidcai.github.io/blog/posts/router-dynamic-templates/</link>
      <pubDate>Sat, 15 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://davidcai.github.io/blog/posts/router-dynamic-templates/</guid>
      <description>

&lt;p&gt;This post discusses how to create dynamic templates by leveraging the templateProvider configuration provided by Angular&amp;rsquo;s built-in router and the third-party UI Router.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;problem:7c673880e38fa750461b975e7ddb6656&#34;&gt;PROBLEM&lt;/h2&gt;

&lt;p&gt;For Single Page Applications (SPAs), we often need to switch views or states inside containers. This is usually done through routers. With either Angular&amp;rsquo;s built-in router or the popular UI Router, we are able to define the relationship between states and their templates. For instance, here we defined a state &lt;code&gt;home&lt;/code&gt; and its template URL &lt;code&gt;app/home/home.html&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;app.config(function($stateProvider) {
  $stateProvider.state(&#39;home&#39;, {
    url: &#39;/&#39;,
    templateUrl: &#39;app/home/home.html&#39;
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In some cases, this state-to-template relationship can not be determined beforehand at the &lt;code&gt;config&lt;/code&gt; time. The decision of what the template or template URL will be used for a state has to wait for the availability of run-time data. For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;User&amp;rsquo;s account type, e.g. show Home version A for members, and version B for public users.&lt;/li&gt;
&lt;li&gt;A/B testing, e.g. a A/B testing service randomly picks from two versions &amp;ndash; A or B.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In either scenario, the template cannot be fixed to &lt;code&gt;app/home/home.html&lt;/code&gt;, and has be to resolved using run-time data.&lt;/p&gt;

&lt;p&gt;Router&amp;rsquo;s &lt;code&gt;templateUrl&lt;/code&gt; configuration accepts a function which can be used to create dynamic template URL. However, we are not able to inject run-time dependencies (e.g. user services, or A/B test services) into the templateUrl function. The only available argument of the &lt;code&gt;templateUrl&lt;/code&gt; function is &lt;code&gt;$stateParams&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$stateProvider.state(&#39;home&#39;, {
  templateUrl: function($stateParams) { // Can not inject dependencies
    return &#39;app/home.&#39; + $stateParams.option + &#39;.html&#39;;
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;solution:7c673880e38fa750461b975e7ddb6656&#34;&gt;SOLUTION&lt;/h2&gt;

&lt;p&gt;The anwser is &lt;code&gt;templateProvder&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Both Angular built-in router and the UI Router have a &lt;code&gt;templateProvider&lt;/code&gt; configuration. &lt;code&gt;templateProvider&lt;/code&gt; accepts a function that can be injected with run-time dependencies.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$stateProvider.state(&#39;home&#39;, {
  templateProvider: function(abTestService) { // abTestService is injected here
    var result = abTestService.pick(&#39;a&#39;, &#39;b&#39;); // Choose version A or B
    return &#39;...&#39;; // Return template content based on the result
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;templateProvider&lt;/code&gt; returns template content (not an URL to the template). We can certainly embed HTML markups directly in JavaScript, but for complicate HTML, it&amp;rsquo;s better to externalize the HTML content to separate template files. Here, we created &lt;code&gt;home-a.html&lt;/code&gt; and &lt;code&gt;home-b.html&lt;/code&gt;, and &lt;code&gt;ngInclude&lt;/code&gt; them in the templateProvider function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- Home version A at app/home/home-a.html --&amp;gt;
&amp;lt;div ng-controller=&amp;quot;HomeAController&amp;quot;&amp;gt;Version A&amp;lt;/div&amp;gt;

&amp;lt;!-- Home version B at app/home/home-b.html --&amp;gt;
&amp;lt;div ng-controller=&amp;quot;HomeBController&amp;quot;&amp;gt;Version B&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$stateProvider.state(&#39;home&#39;, {
  templateProvider: function(abTestService) {
    var result = abTestService.pick(&#39;a&#39;, &#39;b&#39;);

    // ngInclude template content based on the A/B test result
    return &#39;&amp;lt;div ng-include=&amp;quot;\&#39;app/home/home-&#39; + result + &#39;.html\&#39;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#39;;
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;templateProvder&lt;/code&gt; can also return a Promise which is resolved to template content.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$stateProvider.state(&#39;home&#39;, {
  templateProvider: function($http, USER_SERVICE_REST_URL) {

    // Here, we return a promise instead of the template content
    return $http.get(USER_SERVICE_REST_URL).then(function(data) {
      var result = (data.type === &#39;member&#39; ? &#39;a&#39; : &#39;b&#39;);

      // Return the template content
      return &#39;&amp;lt;div ng-include=&amp;quot;\&#39;app/home/home-&#39; + result + &#39;.html\&#39;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#39;;
    });
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;even-better-solution:7c673880e38fa750461b975e7ddb6656&#34;&gt;EVEN BETTER SOLUTION&lt;/h2&gt;

&lt;p&gt;Having &lt;code&gt;ngInclude&lt;/code&gt; in &lt;code&gt;templateProvder&lt;/code&gt; function feels still a bit hackish to me. The ideal solution is to specify a template URL, and then let Angular fetch the content. However, sending separate HTTP requests just to fetch templates seems to be unnecessary web traffic. It will be better if the template content can be cached in the $templateCache service; and then, all I need to do is &lt;code&gt;$templateCache.get(&#39;templateUrl&#39;)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$stateProvider.state(&#39;home&#39;, {
  templateProvider: function(abTestService, $templateCache) {
    var result = abTestService.pick(&#39;a&#39;, &#39;b&#39;);

    // Retrieve the cached template content from $templateCache service
    return $templateCache.get(&#39;app/home/home-&#39; + result + &#39;.html&#39;);
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To achieve this, we need a Gulp task to convert all HTML files under the app/ directory to JavaScript strings, and save the strings in $templateCache.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Load gulp and its plugins
var gulp = require(&#39;gulp&#39;);
var minifyHtml = require(&#39;gulp-minify-html&#39;);
var angularTemplateCache = require(&#39;gulp-angular-templatecache&#39;);


gulp.task(&#39;templates&#39;, function() {

  return cacheTemplates(&#39;src/app/**/*.html&#39;, &#39;app.template.js&#39;);

  function cacheTemplates(input, output) {
    return gulp.src(input) // Get all HTML files
      .pipe(minifyHtml({ // Minify HTML content first
        empty: true,
        spare: true,
        quotes: true
      }))
      .pipe(angularTemplateCache(output, { // Save minified strings to cache
        module: &#39;myApp&#39; // Setup $templateCache for Angular module &#39;myApp&#39;
      }))
      .pipe(gulp.dest(&#39;.tmp/templates/&#39;));

  } // /function cacheTemplates

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, import the generated &lt;code&gt;template.js&lt;/code&gt; in &lt;code&gt;index.html&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&amp;quot;.tmp/templates/app.template.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion:7c673880e38fa750461b975e7ddb6656&#34;&gt;CONCLUSION&lt;/h2&gt;

&lt;p&gt;By leveraging the &lt;code&gt;templateProvder&lt;/code&gt; function that can be injected with dependencies, we are able to resolve template content based on run-time data. This technique is useful for switching among more than one templates for a state, for instance, A/B testing, and swappable content in limited space.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Directive Isolated Scope: @ vs. =</title>
      <link>http://davidcai.github.io/blog/posts/directive-at-vs-equal/</link>
      <pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://davidcai.github.io/blog/posts/directive-at-vs-equal/</guid>
      <description>

&lt;p&gt;Shall I use @ or = to bind scope variables? Their difference is very well explained in Angular&amp;rsquo;s documentation. However, this question still often pops up when I create directives. In this post, I listed some of the major differences between these two.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;interpolation-binding:a300ed22ee47617686df42dbda8a1336&#34;&gt;@: Interpolation Binding&lt;/h2&gt;

&lt;p&gt;&amp;rdquo;@&amp;rdquo; symbols can be used to bind interpolations. Interpolations are {{ }} expressions.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say we have a @-bound scope variable &amp;ndash; &lt;code&gt;name&lt;/code&gt; in a directive:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// A directive
function awesomeWidget() {
  return {
    ...
    scope: {
      name: &#39;@&#39; // @-bound variable
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now can assign interpolation &lt;code&gt;{{ person.name }}&lt;/code&gt; to the @-bound variable &lt;code&gt;name&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- Use interpolation {{ person.name }} for @-bound variables --&amp;gt;
&amp;lt;awesome-widget name=&amp;quot;{{ person.name }}&amp;quot;&amp;gt;&amp;lt;/awesome-widget&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, what will happen if we replace &lt;code&gt;{{ person.name }}&lt;/code&gt; with &lt;code&gt;person.name&lt;/code&gt;? Angular will not throw any error, but the value of &lt;code&gt;scope.name&lt;/code&gt; will be a &lt;code&gt;&#39;person.name&#39;&lt;/code&gt; string instead of the real value of person.name.&lt;/p&gt;

&lt;p&gt;We can also assign primitives (string, number, boolean, and etc.) directly to @-bound values. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;awesome-widget name=&amp;quot;David&amp;quot; age=&amp;quot;26.5&amp;quot; single=&amp;quot;false&amp;quot;&amp;gt;&amp;lt;/awesome-widget&amp;gt;
&amp;lt;!-- Note: &amp;quot;David&amp;quot; here is a string primitive not a variable name --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Angular is smart enough to figure out their types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function awesomeWidget($log) {
  return {
    ...
    scope: {
      name: &#39;@&#39;, age: &#39;@&#39;, single: &#39;@&#39;
    },
    link: function(scope) {
      $log.log(scope.name, typeof scope.name);
      // --&amp;gt; &amp;quot;David&amp;quot;, string
      $log.log(scope.age, typeof scope.age);
      // --&amp;gt; 26.5, number
      $log.log(scope.single, typeof scope.single);
      // --&amp;gt; false, boolean
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;variable-name-binding:a300ed22ee47617686df42dbda8a1336&#34;&gt;=: Variable Name Binding&lt;/h2&gt;

&lt;p&gt;&amp;rdquo;=&amp;rdquo; symbols can be used to bind variable names.&lt;/p&gt;

&lt;p&gt;Here, we have a =-bound variable &amp;ndash; &lt;code&gt;name&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function awesomeWidget() {
  return {
    ...
    scope: {
      name: &#39;=&#39; // =-bound scope variable
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unlike @-bound variables which require interpolations such as &lt;code&gt;{{ person.name }}&lt;/code&gt;, =-bound variables can directly refer to variable names, e.g. &lt;code&gt;person.name&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;awesome-widget name=&amp;quot;person.name&amp;quot;&amp;gt;&amp;lt;/awesome-widget&amp;gt;
&amp;lt;!-- Not {{ person.name }} --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we replace &lt;code&gt;person.name&lt;/code&gt; with &lt;code&gt;{{ person.name }}&lt;/code&gt;, Angular will throw an error this time:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;Error: [$parse:syntax] Syntax Error:
Token &#39;{&#39; invalid key at column 2 of the expression [{{ person.name }}]
starting at [{ person.name }}].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Primitives can also be assigned to =-bound variables. For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;awesome-widget age=&amp;quot;26.5&amp;quot; single=&amp;quot;false&amp;quot;&amp;gt;&amp;lt;/awesome-widget&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, for strings, single quotes are needed. This is different from @-bound values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;awesome-widget name=&amp;quot;&#39;David&#39;&amp;quot;&amp;gt;&amp;lt;/awesome-widget&amp;gt;
&amp;lt;!-- Note: David is wrapped in single quotes --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The single quotes are needed because without the single quotes, Angular will treat &amp;ldquo;David&amp;rdquo; as a variable name instead of a string primitive, which might not be what you wanted.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;one-way-binding:a300ed22ee47617686df42dbda8a1336&#34;&gt;@: One-way Binding&lt;/h2&gt;

&lt;p&gt;@ is for one-way binding - the bound value is passed into a directive&amp;rsquo;s scope, however, any change made to the value inside the directive will not be passed back from the directive. To help myself remember this syntax, I&amp;rsquo;d like to think @ as &amp;lsquo;point at&amp;rsquo; - a one-way direction - from the external scope to a directive&amp;rsquo;s internal scope.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div ng-controller=&amp;quot;MainController&amp;quot;&amp;gt;
  &amp;lt;awesome-widget name=&amp;quot;{{ person.name }}&amp;quot;&amp;gt;&amp;lt;/awesome-widget&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We bind &lt;code&gt;{{ person.name }}&lt;/code&gt; to the directive through the &lt;code&gt;name&lt;/code&gt; attribute. The value of &lt;code&gt;person.name&lt;/code&gt; comes from a person object that is attached to the &lt;code&gt;MainController&lt;/code&gt;&amp;rsquo;s scope:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// A controller
function MainController($scope) {
  $scope.person = { name: &#39;David&#39; };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the directive, the @ symbol is to indicate that &lt;code&gt;name&lt;/code&gt; will be one-way bound to the directive&amp;rsquo;s scope variable &lt;code&gt;scope.name&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// A directive
function awesomeWidget() {
  return {
    ...
    scope: {
      name: &#39;@&#39; // One-way binding
    },
    link: function(scope) {
      // Here we change the name variable on the directive scope
      scope.name = &#39;Serena&#39;;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we change the name variable inside the directive (e.g., in the link function), the changed name will not be passed back from the directive&amp;rsquo;s scope to the controller&amp;rsquo;s scope.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div ng-controller=&amp;quot;MainController&amp;quot;&amp;gt;
  &amp;lt;awesome-widget name=&amp;quot;{{ person.name }}&amp;quot;&amp;gt;&amp;lt;/awesome-widget&amp;gt;

  &amp;lt;!-- In the controller&#39;s scope, person.name will still be &amp;quot;David&amp;quot; instead of &amp;quot;Serena&amp;quot; --&amp;gt;
  {{ person.name }}
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inside awesome-widget&amp;rsquo;s &lt;code&gt;link&lt;/code&gt; function, name is changed from &amp;ldquo;David&amp;rdquo; to &amp;ldquo;Sereana&amp;rdquo;. However, outside of the directive, &lt;code&gt;person.name&lt;/code&gt; is still &amp;ldquo;David&amp;rdquo;. This is because the scope variable &lt;code&gt;name&lt;/code&gt; is one-way bound. The change will not affect the scope outside of its directive.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;two-way-binding:a300ed22ee47617686df42dbda8a1336&#34;&gt;=: Two-way Binding&lt;/h2&gt;

&lt;p&gt;= is for two-way binding, meaning the change made to the bound value will be &amp;ldquo;sync&amp;rsquo;d&amp;rdquo; both inside and outside of a directive. I&amp;rsquo;d like to think the &amp;ldquo;=&amp;rdquo; symbol as &amp;ldquo;bi-directional&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Using the above example, we change &amp;ldquo;@&amp;rdquo; to &amp;ldquo;=&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// A directive
function awesomeWidget() {
  return {
    ...
    scope: {
      name: &#39;=&#39; // Changed to two-way binding
    },
    link: function(scope) {
      scope.name = &#39;Serena&#39;;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that in the HTML template, we also changed &lt;code&gt;{{ person.name }}&lt;/code&gt; to &lt;code&gt;person.name&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div ng-controller=&amp;quot;MainController&amp;quot;&amp;gt;
  &amp;lt;awesome-widget name=&amp;quot;person.name&amp;quot;&amp;gt;&amp;lt;/awesome-widget&amp;gt; &amp;lt;!-- Removed {{ }} --&amp;gt;

  &amp;lt;!-- Now, person.name is changed to &amp;quot;Serena&amp;quot; --&amp;gt;
  {{ person.name }}
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The scope variable &lt;code&gt;name&lt;/code&gt; is changed in directive&amp;rsquo;s &lt;code&gt;link&lt;/code&gt; function. Because &lt;code&gt;name&lt;/code&gt; is two-way bound, the change is also reflected in &lt;code&gt;person.name&lt;/code&gt; on &lt;code&gt;MainControler&lt;/code&gt;&amp;rsquo;s scope.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion:a300ed22ee47617686df42dbda8a1336&#34;&gt;Conclusion&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Type&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Direction&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Value type&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;String primitive&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;@&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;One-way binding&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Interpolations and primitives&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;No single quote: &amp;ldquo;David&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;=&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Two-way binding&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Variable names and primitives&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Single quotes: &amp;ldquo;&amp;lsquo;David&amp;rsquo;&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Angular Factory Pattern</title>
      <link>http://davidcai.github.io/blog/posts/angular-factory-pattern/</link>
      <pubDate>Wed, 05 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://davidcai.github.io/blog/posts/angular-factory-pattern/</guid>
      <description>

&lt;h2 id=&#34;suffix-factory-with-service:2125073d380548c4d6df7eb33c79e543&#34;&gt;Suffix Factory with &amp;lsquo;Service&amp;rsquo;&lt;/h2&gt;

&lt;p&gt;The terminology &amp;ldquo;Factory&amp;rdquo; in Angular is different from the one used in the Java community. From a Java developer&amp;rsquo;s perspective, a factory is to create something by a specification supplied by the factory caller. There should be only one public method on a factory - getInstance(). Well, maybe some variations of the getInstance method. But that should be it. Factories simply create stuff.&lt;/p&gt;

&lt;p&gt;However, in Angular, unlike &lt;code&gt;angular.controller&lt;/code&gt; which creates a controller, what &lt;code&gt;angular.factory&lt;/code&gt; creates is not a factory but a service - a place to host public APIs and encapsulate logics, not a factory that creates stuff. Services certainly could be used to create things, however, the most common usage is to wrap shared code and expose them to consumer code.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;angular.factory&lt;/code&gt; returns a service singleton. That&amp;rsquo;s why I would like to suffix the factory function with &amp;ldquo;Service&amp;rdquo; not &amp;ldquo;Factory&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;angular
  .module(&#39;myApp&#39;)
  // userService instead of userFactory
  .factory(&#39;userService&#39;, userService)
;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;decouple-interface-from-implementation:2125073d380548c4d6df7eb33c79e543&#34;&gt;Decouple Interface from Implementation&lt;/h2&gt;

&lt;p&gt;A common factory looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//
// Not so good
//
angular
  .module(&#39;myApp&#39;)
  .factory(&#39;userService&#39;, userService)
;

function userService($http, $log) {

  // Private variables
  var REST_URL = &#39;/api/users&#39;;

  // Return the service instance
  return {

    // Public methods

    getUsers: function() { ... },
    queryUsers: function(by) { ... }
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing is really wrong with the above example. However, there is room for improvement - the returned service instance is a congealment of both interface and implementation. &lt;code&gt;getUsers&lt;/code&gt; and &lt;code&gt;queryUsers&lt;/code&gt; are interfaces, while their associated anonymous functions are implementation details. If the anonymous functions grow in lines of code, it would be &amp;ldquo;a bit&amp;rdquo; difficult to tell the service interface from implementations. To improve the readability, a common practice is to move the implementations out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//
// Better
//
function userService($http, $log) {

  ...

  // Move implementation here
  var getUsers = function() { ... };
  var queryUsers = function(by) { ... };

  // Keep interface simple
  return {
    getUsers: getUsers
    queryUsers: queryUsers
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;move-declarations-to-top:2125073d380548c4d6df7eb33c79e543&#34;&gt;Move Declarations to Top&lt;/h2&gt;

&lt;p&gt;To push good readability further, I will move declarations above implementations, just like how we define Angular components. Here is an example of Angular controller definition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//
// Good example
//
angular
  .module(&#39;myApp&#39;)
  // Controller declarations. We have two controllers
  .controller(&#39;MainController&#39;, MainController)
  .controller(&#39;SideBarController&#39;, SideBarController)
;

// Controller implementations
function MainController() { ... }
function SideBarController() { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By moving declarations above Implementations, we have a clear manifest of what this Angular script will do. Apply the same principle to factories:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//
// Improved
//
function userService($http) {

  // Declarations, moved up.
  return {
    getUsers: getUsers,
    queryUsers: queryUsers
  };

  // Implementations, moved down.
  // Use function declaration syntax instead of
  // var getUsers = function() { ... };
  function getUsers() { ... }
  function queryUsers(by) { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we use function declaration syntax to define the implementation functions, so they will be hoisted and accessible even before they are defined.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also recommended to have variables defined at top of the function body:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//
// Improved
//
function userService($http) {

  // Declarations
  var var1 = 1;

  return {
    getUsers: getUsers,
    queryUsers: queryUsers
  };

  // Implementations
  function getUsers() { ... }
  function queryUsers(by) { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion:2125073d380548c4d6df7eb33c79e543&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Suffix factories with &amp;lsquo;Service&amp;rsquo;. Leverage function hoisting to pull declarations above implementations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;;(function() {
  &#39;use strict&#39;;

  angular
    .module(&#39;myApp&#39;)
    .factory(&#39;userService&#39;, userService) // Declaration
  ;


  function userService($http, $log) { // Implementation

    // Declaration

    var REST_URL = &#39;/api/users&#39;;

    return {
      getUsers: getUsers,
      queryUsers: queryUsers
    };

    // Implementation

    function getUsers() { ... }

    function queryUsers(by) { ... }
  }

})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same style can be applied to other Angular components, such as directives and filters. Here is a directive example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;;(function() {
  &#39;use strict&#39;;

  angular
    .module(&#39;myApp&#39;)
    .directive(&#39;myAwesomeWidget&#39;, myAwesomeWidget)
  ;


  function myAwesomeWidget($log) {

    // Directive declarations
    return {
      restrict: &#39;AE&#39;,
      scope: {
        options: &#39;=&#39;
      },
      templateUrl: &#39;app/common/myAwesomeWidget.html&#39;,
      link: linkMyAwesomeWidget
    };

    // Link function implementation
    function linkMyAwesomeWidget(scope, elem, attrs) {
      ...
    }
  }
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Angular Best Practice Recap</title>
      <link>http://davidcai.github.io/blog/posts/angular-best-practice-recap/</link>
      <pubDate>Sat, 01 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://davidcai.github.io/blog/posts/angular-best-practice-recap/</guid>
      <description>

&lt;p&gt;I attended a great Angular training provided by OasisDigital the last week. Learned so many tips and best practices from Bill Odom and his team. While my memory is still fresh, I&amp;rsquo;d like to document the stuff I learned. So again, I use my blog as study notes. While I&amp;rsquo;m on the topic of Angular best practices, I also like to bring in some advices from John Papa, Shai Reznik, and other wisdoms of the community. This article basically is a recap of what I heard and learned.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;prefer-factory-over-service:55578ab064fd5af32026dc69791cd223&#34;&gt;PREFER FACTORY OVER SERVICE&lt;/h2&gt;

&lt;p&gt;A service is a simplified version of a factory. Services are a constructor functions. However, I&amp;rsquo;ve seen some service code that returns objects. The author of the code probably mistook services with factories. To clear the confusion, let&amp;rsquo;s favor factories over services. I personally prefer naming a factory as xyzService instead of xyzFactory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;angular
  .module(&#39;myApp&#39;)
  .factory(&#39;fooService&#39;, fooService)
;

function fooService() {
  return {
    getFoo: function() { ... },
    getBar: function() { ... }
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;assign-third-party-globals-to-values:55578ab064fd5af32026dc69791cd223&#34;&gt;ASSIGN THIRD-PARTY GLOBALS TO VALUES&lt;/h2&gt;

&lt;p&gt;Although I can use $window to reference globals of third-party libraries, I like to assign globals to values, and inject them. This makes function arguments a clear contract of what dependencies my code requires.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;angular
  .module(&#39;myApp&#39;)
  .value(&#39;_&#39;, _) // lodash
  .value(&#39;d3&#39;, d3) // D3
;

...

function MainController(_, d3) { // Injection
  _.forEach( ... );
  d3.select( ... );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For low-level libraries (e.g., lodash), I can even delete lodash&amp;rsquo;s global &amp;lsquo;&lt;em&gt;&amp;rsquo; from the window object, so &amp;lsquo;&lt;/em&gt;&amp;rsquo; will be available only through injection:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;angular
  .module(&#39;myApp&#39;)
  .factory(&#39;_&#39;, function() {
    var _ = window._;
    delete window._; // Delete _ from window

    return _;
  })
;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;stick-with-http:55578ab064fd5af32026dc69791cd223&#34;&gt;STICK WITH $HTTP&lt;/h2&gt;

&lt;p&gt;I feel $http gives me more flexibilities than $resource. And $http service&amp;rsquo;s promise interface is much nicer. Better to stick with $http than mixing $http and $resource which unnecessarily complicate my code.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;wrap-rest-in-services:55578ab064fd5af32026dc69791cd223&#34;&gt;WRAP REST IN SERVICES&lt;/h2&gt;

&lt;p&gt;Encapsulate REST requests as methods in services, so users of the service don&amp;rsquo;t have to know the interface of your REST APIs, and the choice of REST libraries ($http, $resource, etc.).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;angular
  .module(&#39;myApp&#39;)
  .factory(&#39;accountService&#39;, accountService)
;

function accountService($http, $log) {
  return {
    getAccounts: function(userId) {
      return $http.get(&#39;/api/accounts/&#39; + userId)
        .then(function(response) {
          return response.data;
        })
        .catch(function(error) {
          $log.error(error);
          return error;
        })
      ;
    }
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ui-router-resolve-pattern:55578ab064fd5af32026dc69791cd223&#34;&gt;UI ROUTER RESOLVE PATTERN&lt;/h2&gt;

&lt;p&gt;I often run to the scenarios where I need to hold off displaying UI until certain data is ready. The resolve property of uiRouter is designed to tackle this common problem.&lt;/p&gt;

&lt;p&gt;Assign a name-to-function map to the resolve property. If the function returns a value, the returned value is treated as dependency, and the value is injected into the controller; if the function returns a promise, the promise is resolved before the controller is instantiated, and the resolved value is injected into the controller.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$stateProvider
  .state(&#39;home&#39;, {
    ... ,

    // Resolve items and users before routing to the &#39;home&#39; state
    resolve: {
      items: function() {
        // Returns an array value
        return [
          { name: &#39;The Settlers of Catan&#39;, price: 51.46 },
          { name: &#39;Mansions of Madness&#39;, price: 56.52 }
        ];
      },
      users: function(userService) {
        // Returns a promise
        return userService.getUsers();
      }
    },

    // items and users are injected to the controller
    controller: function($scope, $log, items, users) {
      $log.log(items);
      $log.log(users);
    }
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;isolate-directive-scope:55578ab064fd5af32026dc69791cd223&#34;&gt;ISOLATE DIRECTIVE SCOPE&lt;/h2&gt;

&lt;p&gt;Think Angular directives as re-usable functions, and its scope as the argument list of a function. In most cases, a directive shouldn&amp;rsquo;t assume the presence of data in the ancestor scopes or elements in the DOM. The scope (and the directive&amp;rsquo;s DOM attributes) should be the only place where a directive retrieves external information.&lt;/p&gt;

&lt;p&gt;Pass information to directives via element attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div data-browse-happy-banner
  data-ie-version=&amp;quot;8&amp;quot;
  data-on-dismiss=&amp;quot;bannerDismissed()&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then retrieve these information from the scope:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;angular
  .module(&#39;myApp&#39;)
  .directive(&#39;browseHappyBanner&#39;, browseHappyBanner)
;

function browseHappyBanner() {
  return {
    restrict: &#39;A&#39;,
    scope: { // Isolated scope
      ieVersion: &#39;@&#39;, // Pass ieVersion from data-ie-version attribute
      onDismiss: &#39;&amp;amp;&#39; // Pass onDismiss callback from data-on-dismiss attribute
    },
    template: &#39;&amp;lt;div&amp;gt; ... &amp;lt;a data-ng-click=&amp;quot;onClose()&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;&#39;,
    ... ,
    link: function(scope) {
      // Retrieve ieVersion from scope
      var iev = parseInt(scope.ieVersion, 10);
      ...
      scope.onClose = function() {
        // Invoke onDismiss callback from the scope
        scope.onDismiss();  
      };
    }
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;clean-template:55578ab064fd5af32026dc69791cd223&#34;&gt;CLEAN TEMPLATE&lt;/h2&gt;

&lt;p&gt;If snippets in a template look like program, then you are doing it wrong. Templates need to be declarative, easy to understand for non-programmers. The best practice is to imagine your template is written by a web designer rather than a developer.&lt;/p&gt;

&lt;p&gt;Will a web designer understand the following template?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div data-ng-class=&amp;quot;{
  &#39;error&#39;: ((bFormSubmitted || PersonalInfoForm.DOBmonth.$dirty) &amp;amp;&amp;amp; PersonalInfoForm.DOBmonth.$invalid) ||
            ((bFormSubmitted || PersonalInfoForm.DOBday.$dirty) &amp;amp;&amp;amp; PersonalInfoForm.DOBday.$invalid) ||
            ((bFormSubmitted || PersonalInfoForm.DOByear.$dirty) &amp;amp;&amp;amp; PersonalInfoForm.DOByear.$invalid ) || errorMapResult.birthdate,
  &#39;success&#39;: (PersonalInfoForm.DOBmonth.$dirty &amp;amp;&amp;amp; !PersonalInfoForm.DOBmonth.$invalid) &amp;amp;&amp;amp;
              (PersonalInfoForm.DOBday.$dirty &amp;amp;&amp;amp; !PersonalInfoForm.DOBday.$invalid) &amp;amp;&amp;amp;
              (PersonalInfoForm.DOByear.$dirty &amp;amp;&amp;amp; !PersonalInfoForm.DOByear.$invalid )}&amp;quot;&amp;gt;
  ...
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Guess no. Even developer might have hard time to understand this. Move the logic to controller or service, so the template becomes clean:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div data-ng-class=&amp;quot;{ &#39;error&#39;: hasError, &#39;success&#39;: isSuccessful }&amp;quot;&amp;gt;
  ...
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;thin-controller:55578ab064fd5af32026dc69791cd223&#34;&gt;THIN CONTROLLER&lt;/h2&gt;

&lt;p&gt;Make controller thin. Move logic to services and directives. This makes controller much easy to test.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;light-filter:55578ab064fd5af32026dc69791cd223&#34;&gt;LIGHT FILTER&lt;/h2&gt;

&lt;p&gt;Filter tends to be called multiple times. So if you have a filter that does a lot of heavy lifting, it will drag down the performance of the entire app. Try to simplify the logic in filter. Use cache or memoization to improve the performance.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
angular
  .module(&amp;quot;myApp&amp;quot;)
  .filter(&amp;quot;heavyLifting&amp;quot;, heavyLifting) // A filter does heavy lifting stuff
;

function heavyLifting() {

  var doHeavyLifting = function() { ... }; // Complicate process

  // Use lodash&#39;s memoize function to cache the returned result for a specific input.
  // Future calls with the same input will return the cached result.
  return _.memoize(function(input) {
    return doHeavyLifting(input);
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More details on filter and memoization can be found &lt;a href=&#34;http://www.terrencewatson.com/2014/06/28/memoize/&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;named-functions:55578ab064fd5af32026dc69791cd223&#34;&gt;NAMED FUNCTIONS&lt;/h2&gt;

&lt;p&gt;Use named functions whenever you can. When error occurs inside the named function, the function name will appear in the stack trace, which is really helpful for debugging.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Named function showToggle
$timeout(function showToggle() {
  angular.element(&#39;.toggle&#39;).css(&#39;display&#39;, &#39;block&#39;);
}, 1000);

// Named function greet
var greet = function greet(name) {
  console.log(&#39;Hello &#39; + name);
};

// Named controller
angular.module(&#39;myApp&#39;).controller(&#39;MyController&#39;, MyController);
function MyController() { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;scope-js-code-in-iife:55578ab064fd5af32026dc69791cd223&#34;&gt;SCOPE JS CODE IN IIFE&lt;/h2&gt;

&lt;p&gt;This best practice is not limited to Angular. IIFE (Immediately-Invoked Function Expression) is often used to create scopes in which the variables and functions will not be leaked to outer scopes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;;(function() {
  ...
  var app = angular.module(&#39;myApp&#39;);
  ...
})();

console.log(app) // not defined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;pyramid-testing:55578ab064fd5af32026dc69791cd223&#34;&gt;PYRAMID TESTING&lt;/h2&gt;

&lt;p&gt;Again this advice is not limited to Angular.&lt;/p&gt;

&lt;p&gt;Write more unit tests. Treat unit tests as front-line defense. Use e2e protractor tests as high-level tests for verifying critical happy and error paths.&lt;/p&gt;

&lt;p&gt;Martin Fowler discussed &lt;a href=&#34;http://martinfowler.com/bliki/TestPyramid.html&#34;&gt;Test pyramid&lt;/a&gt; in his blog.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://davidcai.github.io/blog/img/pyramid.png&#34; alt=&#34;Test Pyramid&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ng-model-dot-rule:55578ab064fd5af32026dc69791cd223&#34;&gt;NG-MODEL DOT RULE&lt;/h2&gt;

&lt;p&gt;Misko Hevery in his presentation on Angular best practices coined the &lt;a href=&#34;https://www.youtube.com/watch?feature=player_detailpage&amp;amp;v=ZhfUv0spHCY#t=1758s&#34;&gt;dot rule&lt;/a&gt;. My over-simplified version is to bind objects instead of primitives to $scope, and always initialize the bound object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function MainController($scope) {
  $scope.something = {}; // Always initialize the bound objects

  $scope.person = {
    name: &#39;David Cai&#39;
  }; // Bind objects to $scope instead of $scope.name = &#39;David Cai&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the HTML template:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div ng-controller=&amp;quot;MainController&amp;quot;&amp;gt;
  &amp;lt;input ng-model=&amp;quot;person.name&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;one-component-per-file:55578ab064fd5af32026dc69791cd223&#34;&gt;ONE COMPONENT PER FILE&lt;/h2&gt;

&lt;p&gt;Limit one Angular component (directive, service, controller, etc.) per JavaScript file. Make it easy to locate components, and keep files shorter.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;angular
  .module(&#39;myApp&#39;)
  .directive(&#39;myAwesomeWidget&#39;, function() { ... })

  // Don&#39;t.
  // We already defined a directive in this file.
  // Move the following directive to another file.
  .directive(&#39;myOtherAwesomeWidget&#39;, function() { ... })
;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;group-files-by-features:55578ab064fd5af32026dc69791cd223&#34;&gt;GROUP FILES BY FEATURES&lt;/h2&gt;

&lt;p&gt;There are two schools of thoughts when it comes to organizing Angular files - grouping by types, and grouping by features. I prefer the latter for big projects. Much easier for navigation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;common
  - util.filter.js
  - util.filter.spec.js
action-panel
  - action-panel.directive.js
  - action-panel.directive.spec.js
  - action-panel.html
  - action-panel.scss
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;include-intention-in-file-names:55578ab064fd5af32026dc69791cd223&#34;&gt;INCLUDE INTENTION IN FILE NAMES&lt;/h2&gt;

&lt;p&gt;.js can mean a lot of things in Angular apps. It makes the intention much clear when the file names contain .controller, .directive, .spec, .service, etc.&lt;/p&gt;

&lt;p&gt;Shai Reznik recommends using .ctrl for controllers, .drv for directives, .srv for services., .tpl for templates, and .test for unit tests. I prefer full names, e.g. .controller. I also feel that HTML files don&amp;rsquo;t need .tpl or .template, since in most cases, HTML files are templates. No need to explicitly call them out as templates.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;lint-javascript:55578ab064fd5af32026dc69791cd223&#34;&gt;LINT JAVASCRIPT&lt;/h2&gt;

&lt;p&gt;Use jshint, JSCS, or even better - &lt;a href=&#34;http://eslint.org/&#34;&gt;eslint&lt;/a&gt; to lint javascript code. Integrate lint into the build process. Use editor plugins to bring lint warnings and errors right in front of developers&amp;rsquo;s eyes. I&amp;rsquo;ve been considering to create GIT hook to block git pushes if lint reports any warnings or errors.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;use-ng-annotate:55578ab064fd5af32026dc69791cd223&#34;&gt;USE NG-ANNOTATE&lt;/h2&gt;

&lt;p&gt;Angular replies on the names of function arguments for dependency injection. However, JS minification will shorten argument names, which ruined Angular DI. To work around this issue, we either use the DI array syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// DI array syntax
app.controller(&#39;MainController&#39;, [&#39;$scope&#39;, &#39;$log&#39;, function($scope, $log) {
  ...
}]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; or assign dependencies to the $inject property:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// $inject syntax
MainController.$inject = [&#39;$scope&#39;, &#39;$log&#39;];
function MainController($scope, $log) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These workarounds look like patchwork to me. Not to mention that both are error prone where you have to maintain the dependency order in arrays.&lt;/p&gt;

&lt;p&gt;Here comes &lt;a href=&#34;https://github.com/olov/ng-annotate&#34;&gt;ngAnnotate&lt;/a&gt; - an Angular plugin that automatically inserts the DI array syntax in source code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// ngAnnotate will replace function($scope, $log) { ... } with
// [&#39;$scope&#39;, &#39;$log&#39;, function($scope, $log) { ... }]
app.controller(&#39;MainController&#39;, function($scope, $log) {
  ...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although ngAnnotate is quite smart to figure out where to annotate DI syntax, in some cases, ngAnnotate might miss the DI annotation for a function. You can prepend a function with &lt;code&gt;/*@ngInject*/&lt;/code&gt; to explicitly state that the function should get annotated.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;leverage-task-runners:55578ab064fd5af32026dc69791cd223&#34;&gt;LEVERAGE TASK RUNNERS&lt;/h2&gt;

&lt;p&gt;Lint and ngAnnotate can be integrated in the build process by task runners such as Gulp.&lt;/p&gt;

&lt;p&gt;Use Gulp to automate:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JS lint - &lt;a href=&#34;https://github.com/adametry/gulp-eslint&#34;&gt;gulp-eslint&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ngAnnotate - &lt;a href=&#34;https://github.com/Kagami/gulp-ng-annotate&#34;&gt;gulp-ng-annotate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Sort angular files - &lt;a href=&#34;https://github.com/klei/gulp-angular-filesort&#34;&gt;gulp-angular-filesort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Convert HTML templates to JS strings in $templateCache - &lt;a href=&#34;https://github.com/miickel/gulp-angular-templatecache&#34;&gt;gulp-angular-templatecache&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Let&#39;s use NVM</title>
      <link>http://davidcai.github.io/blog/posts/lets-use-nvm/</link>
      <pubDate>Sun, 14 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://davidcai.github.io/blog/posts/lets-use-nvm/</guid>
      <description>

&lt;p&gt;My colleague just came to me with a troubled face. He couldn&amp;rsquo;t figure out why his gulp script failed to start up local server where everyone else is able to do so. After a short debugging session, I found that the culprit is Node JS version. Certainly, our gulp scripts have a conflict with the latest Node JS. Now, my colleague has to downgrade his Node JS installation, or does he have to? :)&lt;/p&gt;

&lt;p&gt;In this fast-moving industry, maintaining specific versions for your libraries or tools seems to be a chore. That&amp;rsquo;s why there are so many xyz managers, e.g. pip, apt-get, bower, npm, jspm, and homebrew, etc. For managing versions of Node JS, there is NVM - Node Version Manager. I highly recommend using it to have better controls of which version of Node I use.&lt;/p&gt;

&lt;p&gt;If you already installed Node via other installers, it&amp;rsquo;s better to completely remove the existing Node and NPM. To do that, I stole the following command from this stackoverflow thread - &lt;a href=&#34;http://stackoverflow.com/questions/11177954/how-do-i-completely-uninstall-node-js-and-reinstall-from-beginning-mac-os-x&#34;&gt;How do I completely uninstall Node.js, and reinstall from beginning (Mac OS X)&lt;/a&gt;. Here are the commands:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;lsbom -f -l -s -pf /var/db/receipts/org.nodejs.pkg.bom | while read f; do  sudo rm /usr/local/${f}; done

sudo rm -rf /usr/local/lib/node /usr/local/lib/node_modules /var/db/receipts/org.nodejs.*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That should remove all Node JS and NPM from Mac OS X. Now let&amp;rsquo;s install NVM. As of June 2015, the following might be the easiest command to install NVM:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.25.4/install.sh | bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Note: It&amp;rsquo;s always safe to check if &lt;a href=&#34;https://github.com/creationix/nvm&#34;&gt;NVM&lt;/a&gt; updated their installation command.)&lt;/p&gt;

&lt;p&gt;The install.sh script will insert a few lines to ~/.bashrc, however, Mac OS X for some reason won&amp;rsquo;t source ~/.bashrc (&lt;a href=&#34;http://apple.stackexchange.com/questions/119711/why-mac-os-x-dont-source-bashrc&#34;&gt;see details&lt;/a&gt;). So we have to copy the inserted lines to ~/.bash_profile instead:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Node version manager
export NVM_DIR=&amp;quot;/Users/your_username/.nvm&amp;quot;
[ -s &amp;quot;$NVM_DIR/nvm.sh&amp;quot; ] &amp;amp;&amp;amp; . &amp;quot;$NVM_DIR/nvm.sh&amp;quot;  # This loads nvm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Change your_username to your home dir name. After sourcing ~/.bash_profile, NVM will be loaded and ready to use.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;source ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s install Node JS, for example, version 0.10.38:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nvm install 0.10.38
nvm use 0.10.38
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Type &lt;code&gt;node -v&lt;/code&gt; to check if the correct version is installed and in use.&lt;/p&gt;

&lt;p&gt;Node 0.10.38 is installed. However, it will be a bit tedious to type &lt;code&gt;nvm use 0.10.38&lt;/code&gt; to switch to that version every time a terminal session starts. To fix that, I assign &amp;lsquo;default&amp;rsquo; as an alias to v0.10.38:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nvm alias default 0.10.38
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Versions tied to the &amp;lsquo;default&amp;rsquo; alias will be the default active version.&lt;/p&gt;

&lt;p&gt;You are free to install many versions of Node JS with NVM. For instance, here we install the stable version (0.12.4 as of June 2015):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nvm install stable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To list all installed Node Js, and see which one is active, use the &lt;code&gt;nvm ls&lt;/code&gt; command:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://davidcai.github.io/blog/img/nvm-ls.png&#34; alt=&#34;nvm ls&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;The command reports that I have v0.10.38 and v0.12.4 installed. The current active version is 0.10.38. I have four aliases - default, node, sable, and iojs. Aliases can refer to other aliases. In this example, node refers stable, and stable refers 0.12.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion:873ad2aa58948dc097de69876bea24cc&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Managing versions is crucial but tedious. The task should be automated. NVM helps us manage multiple Node Js versions without a sweat. It becomes much easy to work in a working version, and try something new in the latest version. All I have to do is &lt;code&gt;nvm use default&lt;/code&gt; and &lt;code&gt;nvm use stable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;And a side benefit is that I don&amp;rsquo;t have to &lt;code&gt;sudo npm install&lt;/code&gt; any more. Just &lt;code&gt;npm install&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>